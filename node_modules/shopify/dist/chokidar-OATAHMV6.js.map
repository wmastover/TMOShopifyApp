{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/constants.js", "../../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/nodefs-handler.js", "../../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/fsevents-handler.js", "../../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/index.js"],
  "sourcesContent": ["'use strict';\n\nconst {sep} = require('path');\nconst {platform} = process;\nconst os = require('os');\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.SLASH_SLASH = '//';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\nexports.isLinux = platform === 'linux';\nexports.isIBMi = os.type() === 'OS400';\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n", "'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_FLAG_MUST_SCAN_SUBDIRS,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n", "'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You\u2019re frozen when your heart\u2019s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount += paths.length;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n"],
  "mappings": "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",
  "names": ["rawEmitter", "listener", "newStats", "stats", "path", "now", "stat"]
}
