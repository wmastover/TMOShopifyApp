{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/network-interfaces@1.1.0/node_modules/network-interfaces/index.js", "../../cli-kit/src/private/node/analytics.ts", "../../cli-kit/src/private/node/session.ts", "../../cli-kit/src/private/node/session/identity.ts", "../../cli-kit/src/private/node/session/validate.ts", "../../cli-kit/src/private/node/session/schema.ts", "../../cli-kit/src/private/node/session/identity-token-validation.ts", "../../cli-kit/src/public/node/context/fqdn.ts", "../../cli-kit/src/public/node/vendor/dev_server/DevServer.ts", "../../cli-kit/src/public/node/result.ts", "../../cli-kit/src/private/node/session/scopes.ts", "../../cli-kit/src/private/node/session/exchange.ts", "../../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/index.js", "../../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/runtime/base64url.js", "../../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/lib/buffer_utils.js", "../../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/errors.js", "../../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/lib/is_object.js", "../../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/base64url.js", "../../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/decode_jwt.js", "../../cli-kit/src/private/node/session/store.ts", "../../cli-kit/src/private/node/session/device-authorization.ts", "../../cli-kit/src/private/node/api/rest.ts"],
  "sourcesContent": ["'use strict';\n\nconst os = require('os');\n\n\nfunction isValid(address, options) {\n\tif (typeof options.internal === 'boolean' && address.internal !== options.internal) {\n\t\treturn false;\n\t}\n\n\tif (options.ipVersion === 4 && address.family !== 'IPv4') {\n\t\treturn false;\n\t}\n\n\tif (options.ipVersion === 6 && address.family !== 'IPv6') {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\nfunction findAddresses(interfaceName, options = {}) {\n\tconst addresses = os.networkInterfaces()[interfaceName];\n\tif (!addresses) {\n\t\tthrow new Error(`Network interface \"${interfaceName}\" does not exist`);\n\t}\n\n\tconst result = [];\n\n\n\tfor (const address of addresses) {\n\t\tif (isValid(address, options)) {\n\t\t\tresult.push(address);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n\n/**\n * Returns an IP address on the given interface name, filtered by the given options\n *\n * @param {string} interfaceName\n * @param {Object} [options]\n * @param {boolean} [options.internal]   If given, returns only internal addresses if true, or only external if false\n * @param {integer} [options.ipVersion]  If given, returns only addresses who match this IP version (4 or 6)\n * @returns {string}                     The first IP address found\n */\nexports.toIp = function (interfaceName, options) {\n\tconst addresses = findAddresses(interfaceName, options);\n\n\tif (addresses.length === 0) {\n\t\tthrow new Error(`No suitable IP address found on interface \"${interfaceName}\"`);\n\t}\n\n\treturn addresses[0].address;\n};\n\n\n/**\n * Returns all IP addresses on the given interface name, filtered by the given options\n *\n * @param {string} interfaceName\n * @param {Object} [options]\n * @param {boolean} [options.internal]   If given, returns only internal addresses if true, or only external if false\n * @param {integer} [options.ipVersion]  If given, returns only addresses who match this IP version (4 or 6)\n * @returns {string[]}                   All matching IP addresses\n */\nexports.toIps = function (interfaceName, options) {\n\treturn findAddresses(interfaceName, options).map((address) => address.address);\n};\n\n\n/**\n * Returns a network interface name for the given IP address, filtered by the given options\n *\n * @param {string} ip\n * @param {Object} [options]\n * @param {boolean} [options.internal]   If given, only evaluates internal addresses if true, or only external if false\n * @param {integer} [options.ipVersion]  If given, only evaluates addresses who match this IP version (4 or 6)\n * @returns {string}                     The interface name that the given IP is bound to\n */\nexports.fromIp = function (ip, options) {\n\tconst interfaces = os.networkInterfaces();\n\tconst interfaceNames = Object.keys(interfaces);\n\n\tfor (const interfaceName of interfaceNames) {\n\t\tfor (const address of interfaces[interfaceName]) {\n\t\t\tif (address.address === ip && isValid(address, options)) {\n\t\t\t\treturn interfaceName;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow new Error(`No suitable interfaces were found with IP address \"${ip}\"`);\n};\n\n\n/**\n * Returns the first network interface name that contains at least one IP address that matches the given options\n *\n * @param {Object} [options]\n * @param {boolean} [options.internal]   If given, only evaluates internal addresses if true, or only external if false\n * @param {integer} [options.ipVersion]  If given, only evaluates addresses who match this IP version (4 or 6)\n * @returns {string}                     The matching interface name\n */\nexports.getInterface = function (options) {\n\tconst interfaces = os.networkInterfaces();\n\tconst interfaceNames = Object.keys(interfaces);\n\n\tfor (const interfaceName of interfaceNames) {\n\t\tif (findAddresses(interfaceName, options).length > 0) {\n\t\t\treturn interfaceName;\n\t\t}\n\t}\n\n\tthrow new Error(`No suitable interfaces were found`);\n};\n\n\n/**\n * Returns all network interface names that contain at least one IP address that matches the given options\n *\n * @param {Object} [options]\n * @param {boolean} [options.internal]   If given, only evaluates internal addresses if true, or only external if false\n * @param {integer} [options.ipVersion]  If given, only evaluates addresses who match this IP version (4 or 6)\n * @returns {string[]}                   The matching interface names\n */\nexports.getInterfaces = function (options) {\n\tconst interfaces = os.networkInterfaces();\n\tconst interfaceNames = Object.keys(interfaces);\n\n\tconst result = [];\n\n\tfor (const interfaceName of interfaceNames) {\n\t\tif (findAddresses(interfaceName, options).length > 0) {\n\t\t\tresult.push(interfaceName);\n\t\t}\n\t}\n\n\treturn result;\n};\n", "import {getLastSeenAuthMethod} from './session.js'\nimport {hashString} from '../../public/node/crypto.js'\nimport {getPackageManager, packageManagerFromUserAgent} from '../../public/node/node-package-manager.js'\nimport BaseCommand from '../../public/node/base-command.js'\nimport {CommandContent} from '../../public/node/hooks/prerun.js'\nimport * as metadata from '../../public/node/metadata.js'\nimport {platformAndArch} from '../../public/node/os.js'\nimport {Command, Interfaces} from '@oclif/core'\nimport {ciPlatform, cloudEnvironment, macAddress} from '@shopify/cli-kit/node/context/local'\nimport {cwd} from '@shopify/cli-kit/node/path'\nimport {currentProcessIsGlobal} from '@shopify/cli-kit/node/is-global'\n\ninterface StartOptions {\n  commandContent: CommandContent\n  args: string[]\n  currentTime?: number\n  commandClass?: Command.Class | typeof BaseCommand\n}\n\nexport async function startAnalytics({\n  commandContent,\n  args,\n  currentTime = new Date().getTime(),\n  commandClass,\n}: StartOptions): Promise<void> {\n  let startCommand: string = commandContent.command\n  if (commandClass && Object.prototype.hasOwnProperty.call(commandClass, 'analyticsNameOverride')) {\n    startCommand = (commandClass as typeof BaseCommand).analyticsNameOverride() ?? commandContent.command\n  }\n\n  let pluginName = commandClass?.plugin?.name\n  if (commandClass && 'customPluginName' in commandClass) {\n    pluginName = commandClass.customPluginName as string\n  }\n\n  await metadata.addSensitiveMetadata(() => ({\n    commandStartOptions: {\n      startTime: currentTime,\n      startCommand,\n      startArgs: args,\n    },\n  }))\n\n  await metadata.addPublicMetadata(() => ({\n    cmd_all_launcher: packageManagerFromUserAgent(),\n    cmd_all_alias_used: commandContent.alias,\n    cmd_all_topic: commandContent.topic,\n    cmd_all_plugin: pluginName,\n    cmd_all_force: flagIncluded('force', commandClass) ? args.includes('--force') : undefined,\n  }))\n}\n\ninterface EnvironmentData {\n  uname: string\n  env_ci: boolean\n  env_ci_platform?: string\n  env_plugin_installed_any_custom: boolean\n  env_plugin_installed_shopify: string\n  env_shell: string\n  env_web_ide: string | undefined\n  env_device_id: string\n  env_cloud: string\n  env_package_manager: string\n  env_is_global: boolean\n  env_auth_method: string\n}\n\nexport async function getEnvironmentData(config: Interfaces.Config): Promise<EnvironmentData> {\n  const ciplatform = ciPlatform()\n\n  const pluginNames = getPluginNames(config)\n  const shopifyPlugins = pluginNames.filter((plugin) => plugin.startsWith('@shopify/'))\n\n  const {platform, arch} = platformAndArch()\n\n  return {\n    uname: `${platform} ${arch}`,\n    env_ci: ciplatform.isCI,\n    env_ci_platform: ciplatform.name,\n    env_plugin_installed_any_custom: pluginNames.length !== shopifyPlugins.length,\n    env_plugin_installed_shopify: JSON.stringify(shopifyPlugins),\n    env_shell: config.shell,\n    env_web_ide: cloudEnvironment().editor ? cloudEnvironment().platform : undefined,\n    env_device_id: hashString(await macAddress()),\n    env_cloud: cloudEnvironment().platform,\n    env_package_manager: await getPackageManager(cwd()),\n    env_is_global: currentProcessIsGlobal(),\n    env_auth_method: await getLastSeenAuthMethod(),\n  }\n}\n\nexport async function getSensitiveEnvironmentData(config: Interfaces.Config) {\n  return {\n    env_plugin_installed_all: JSON.stringify(getPluginNames(config)),\n  }\n}\n\nfunction getPluginNames(config: Interfaces.Config) {\n  const pluginNames = [...config.plugins.keys()]\n  return pluginNames.sort().filter((plugin) => !plugin.startsWith('@oclif/'))\n}\n\nfunction flagIncluded(flag: string, commandClass?: Command.Class | typeof BaseCommand) {\n  if (!commandClass) return false\n\n  const commandFlags = commandClass.flags ?? {}\n  return Object.keys(commandFlags).includes(flag)\n}\n", "import {applicationId} from './session/identity.js'\nimport {validateSession} from './session/validate.js'\nimport {allDefaultScopes, apiScopes} from './session/scopes.js'\nimport {\n  exchangeAccessForApplicationTokens,\n  exchangeCustomPartnerToken,\n  ExchangeScopes,\n  refreshAccessToken,\n  InvalidGrantError,\n  InvalidRequestError,\n} from './session/exchange.js'\nimport {IdentityToken, Session} from './session/schema.js'\nimport * as secureStore from './session/store.js'\nimport {pollForDeviceAuthorization, requestDeviceAuthorization} from './session/device-authorization.js'\nimport {isThemeAccessSession} from './api/rest.js'\nimport {outputContent, outputToken, outputDebug} from '../../public/node/output.js'\nimport {firstPartyDev, themeToken} from '../../public/node/context/local.js'\nimport {AbortError, BugError} from '../../public/node/error.js'\nimport {normalizeStoreFqdn, identityFqdn} from '../../public/node/context/fqdn.js'\nimport {getIdentityTokenInformation, getPartnersToken} from '../../public/node/environment.js'\nimport {AdminSession} from '@shopify/cli-kit/node/session'\nimport {outputCompleted} from '@shopify/cli-kit/node/output'\nimport {isSpin} from '@shopify/cli-kit/node/context/spin'\nimport {nonRandomUUID} from '@shopify/cli-kit/node/crypto'\n\n/**\n * A scope supported by the Shopify Admin API.\n */\nexport type AdminAPIScope = 'graphql' | 'themes' | 'collaborator'\n\n/**\n * It represents the options to authenticate against the Shopify Admin API.\n */\n\ninterface AdminAPIOAuthOptions {\n  /** Store to request permissions for. */\n  storeFqdn: string\n  /** List of scopes to request permissions for. */\n  scopes: AdminAPIScope[]\n}\n\n/**\n * A scope supported by the Partners API.\n */\nexport type PartnersAPIScope = 'cli'\ninterface PartnersAPIOAuthOptions {\n  /** List of scopes to request permissions for. */\n  scopes: PartnersAPIScope[]\n}\n\n/**\n * A scope supported by the Developer Platform API.\n */\nexport type AppManagementAPIScope = 'https://api.shopify.com/auth/organization.apps.manage'\ninterface AppManagementAPIOauthOptions {\n  /** List of scopes to request permissions for. */\n  scopes: AppManagementAPIScope[]\n}\n\n/**\n * A scope supported by the Storefront Renderer API.\n */\nexport type StorefrontRendererScope = 'devtools'\ninterface StorefrontRendererAPIOAuthOptions {\n  /** List of scopes to request permissions for. */\n  scopes: StorefrontRendererScope[]\n}\n\nexport type BusinessPlatformScope = 'destinations'\ninterface BusinessPlatformAPIOAuthOptions {\n  /** List of scopes to request permissions for. */\n  scopes: BusinessPlatformScope[]\n}\n\n/**\n * It represents the authentication requirements and\n * is the input necessary to trigger the authentication\n * flow.\n */\nexport interface OAuthApplications {\n  adminApi?: AdminAPIOAuthOptions\n  storefrontRendererApi?: StorefrontRendererAPIOAuthOptions\n  partnersApi?: PartnersAPIOAuthOptions\n  businessPlatformApi?: BusinessPlatformAPIOAuthOptions\n  appManagementApi?: AppManagementAPIOauthOptions\n}\n\nexport interface OAuthSession {\n  admin?: AdminSession\n  partners?: string\n  storefront?: string\n  businessPlatform?: string\n  appManagement?: string\n  userId: string\n}\n\ntype AuthMethod = 'partners_token' | 'device_auth' | 'theme_access_token' | 'custom_app_token' | 'none'\n\nlet userId: undefined | string\nlet authMethod: AuthMethod = 'none'\n\n/**\n * Retrieves the user ID from the current session or returns 'unknown' if not found.\n *\n * This function performs the following steps:\n * 1. Checks for a cached user ID in memory (obtained in the current run).\n * 2. Attempts to fetch it from the secure store (from a previous auth session).\n * 3. Checks if a custom token was used (either as a theme password or partners token).\n * 4. If a custom token is present in the environment, generates a UUID and uses it as userId.\n * 5. If after all this we don't have a userId, then reports as 'unknown'.\n *\n * @returns A Promise that resolves to the user ID as a string.\n */\nexport async function getLastSeenUserIdAfterAuth(): Promise<string> {\n  if (userId) return userId\n\n  const currentSession = (await secureStore.fetch()) || {}\n  const fqdn = await identityFqdn()\n  const cachedUserId = currentSession[fqdn]?.identity.userId\n  if (cachedUserId) return cachedUserId\n\n  const customToken = getPartnersToken() ?? themeToken()\n  return customToken ? nonRandomUUID(customToken) : 'unknown'\n}\n\nexport function setLastSeenUserIdAfterAuth(id: string) {\n  userId = id\n}\n\n/**\n * Retrieves the last seen authentication method used in the current session.\n *\n * This function checks for the authentication method in the following order:\n * 1. Returns the cached auth method if it's not 'none'.\n * 2. Checks for a cached session, which implies 'device_auth' was used.\n * 3. Checks for a partners token in the environment.\n * 4. Checks for a theme password in the environment.\n * 5. If none of the above are true, returns 'none'.\n *\n * @returns A Promise that resolves to the last seen authentication method as an AuthMethod type.\n */\nexport async function getLastSeenAuthMethod(): Promise<AuthMethod> {\n  if (authMethod !== 'none') return authMethod\n\n  const currentSession = (await secureStore.fetch()) || {}\n  const fqdn = await identityFqdn()\n  const cachedUserId = currentSession[fqdn]?.identity.userId\n  if (cachedUserId) return 'device_auth'\n\n  const partnersToken = getPartnersToken()\n  if (partnersToken) return 'partners_token'\n\n  const themePassword = themeToken()\n  if (themePassword) {\n    return isThemeAccessSession({token: themePassword, storeFqdn: ''}) ? 'theme_access_token' : 'custom_app_token'\n  }\n\n  return 'none'\n}\n\nexport function setLastSeenAuthMethod(method: AuthMethod) {\n  authMethod = method\n}\n\n/**\n * This method ensures that we have a valid session to authenticate against the given applications using the provided scopes.\n *\n * @param applications - An object containing the applications we need to be authenticated with.\n * @param _env - Optional environment variables to use.\n * @param forceRefresh - Optional flag to force a refresh of the token.\n * @returns An instance with the access tokens organized by application.\n */\nexport async function ensureAuthenticated(\n  applications: OAuthApplications,\n  _env?: NodeJS.ProcessEnv,\n  {forceRefresh = false, noPrompt = false}: {forceRefresh?: boolean; noPrompt?: boolean} = {},\n): Promise<OAuthSession> {\n  const fqdn = await identityFqdn()\n\n  const previousStoreFqdn = applications.adminApi?.storeFqdn\n  if (previousStoreFqdn) {\n    const normalizedStoreName = await normalizeStoreFqdn(previousStoreFqdn)\n    if (previousStoreFqdn === applications.adminApi?.storeFqdn) {\n      applications.adminApi.storeFqdn = normalizedStoreName\n    }\n  }\n\n  const currentSession = (await secureStore.fetch()) || {}\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const fqdnSession = currentSession[fqdn]!\n  const scopes = getFlattenScopes(applications)\n\n  outputDebug(outputContent`Validating existing session against the scopes:\n${outputToken.json(scopes)}\nFor applications:\n${outputToken.json(applications)}\n`)\n  const validationResult = await validateSession(scopes, applications, fqdnSession)\n\n  let newSession = {}\n\n  function throwOnNoPrompt() {\n    if (!noPrompt || (isSpin() && firstPartyDev())) return\n    throw new AbortError(\n      `The currently available CLI credentials are invalid.\n\nThe CLI is currently unable to prompt for reauthentication.`,\n      'Restart the CLI process you were running. If in an interactive terminal, you will be prompted to reauthenticate. If in a non-interactive terminal, ensure the correct credentials are available in the program environment.',\n    )\n  }\n\n  if (validationResult === 'needs_full_auth') {\n    throwOnNoPrompt()\n    outputDebug(outputContent`Initiating the full authentication flow...`)\n    newSession = await executeCompleteFlow(applications, fqdn)\n  } else if (validationResult === 'needs_refresh' || forceRefresh) {\n    outputDebug(outputContent`The current session is valid but needs refresh. Refreshing...`)\n    try {\n      newSession = await refreshTokens(fqdnSession.identity, applications, fqdn)\n    } catch (error) {\n      if (error instanceof InvalidGrantError) {\n        throwOnNoPrompt()\n        newSession = await executeCompleteFlow(applications, fqdn)\n      } else if (error instanceof InvalidRequestError) {\n        await secureStore.remove()\n        throw new AbortError('\\nError validating auth session', \"We've cleared the current session, please try again\")\n      } else {\n        throw error\n      }\n    }\n  }\n\n  const completeSession: Session = {...currentSession, ...newSession}\n\n  // Save the new session info if it has changed\n  if (Object.keys(newSession).length > 0) await secureStore.store(completeSession)\n  const tokens = await tokensFor(applications, completeSession, fqdn)\n\n  // Overwrite partners token if using a custom CLI Token\n  const envToken = getPartnersToken()\n  if (envToken && applications.partnersApi) {\n    tokens.partners = (await exchangeCustomPartnerToken(envToken)).accessToken\n  }\n\n  setLastSeenAuthMethod(envToken ? 'partners_token' : 'device_auth')\n  setLastSeenUserIdAfterAuth(tokens.userId)\n  return tokens\n}\n\n/**\n * Execute the full authentication flow.\n *\n * @param applications - An object containing the applications we need to be authenticated with.\n * @param identityFqdn - The identity FQDN.\n */\nasync function executeCompleteFlow(applications: OAuthApplications, identityFqdn: string): Promise<Session> {\n  const scopes = getFlattenScopes(applications)\n  const exchangeScopes = getExchangeScopes(applications)\n  const store = applications.adminApi?.storeFqdn\n  if (firstPartyDev()) {\n    outputDebug(outputContent`Authenticating as Shopify Employee...`)\n    scopes.push('employee')\n  }\n\n  let identityToken: IdentityToken\n  const identityTokenInformation = getIdentityTokenInformation()\n  if (identityTokenInformation) {\n    identityToken = buildIdentityTokenFromEnv(scopes, identityTokenInformation)\n  } else {\n    // Request a device code to authorize without a browser redirect.\n    outputDebug(outputContent`Requesting device authorization code...`)\n    const deviceAuth = await requestDeviceAuthorization(scopes)\n\n    // Poll for the identity token\n    outputDebug(outputContent`Starting polling for the identity token...`)\n    identityToken = await pollForDeviceAuthorization(deviceAuth.deviceCode, deviceAuth.interval)\n  }\n\n  // Exchange identity token for application tokens\n  outputDebug(outputContent`CLI token received. Exchanging it for application tokens...`)\n  const result = await exchangeAccessForApplicationTokens(identityToken, exchangeScopes, store)\n\n  const session: Session = {\n    [identityFqdn]: {\n      identity: identityToken,\n      applications: result,\n    },\n  }\n\n  outputCompleted('Logged in.')\n\n  return session\n}\n\n/**\n * Refresh the tokens for a given session.\n *\n * @param token - Identity token.\n * @param applications - An object containing the applications we need to be authenticated with.\n * @param fqdn - The identity FQDN.\n */\nasync function refreshTokens(token: IdentityToken, applications: OAuthApplications, fqdn: string): Promise<Session> {\n  // Refresh Identity Token\n  const identityToken = await refreshAccessToken(token)\n  // Exchange new identity token for application tokens\n  const exchangeScopes = getExchangeScopes(applications)\n  const applicationTokens = await exchangeAccessForApplicationTokens(\n    identityToken,\n    exchangeScopes,\n    applications.adminApi?.storeFqdn,\n  )\n\n  return {\n    [fqdn]: {\n      identity: identityToken,\n      applications: applicationTokens,\n    },\n  }\n}\n\n/**\n * Get the application tokens for a given session.\n *\n * @param applications - An object containing the applications we need the tokens for.\n * @param session - The current session.\n * @param fqdn - The identity FQDN.\n */\nasync function tokensFor(applications: OAuthApplications, session: Session, fqdn: string): Promise<OAuthSession> {\n  const fqdnSession = session[fqdn]\n  if (!fqdnSession) {\n    throw new BugError('No session found after ensuring authenticated')\n  }\n  const tokens: OAuthSession = {\n    userId: fqdnSession.identity.userId,\n  }\n  if (applications.adminApi) {\n    const appId = applicationId('admin')\n    const realAppId = `${applications.adminApi.storeFqdn}-${appId}`\n    const token = fqdnSession.applications[realAppId]?.accessToken\n    if (token) {\n      tokens.admin = {token, storeFqdn: applications.adminApi.storeFqdn}\n    }\n  }\n\n  if (applications.partnersApi) {\n    const appId = applicationId('partners')\n    tokens.partners = fqdnSession.applications[appId]?.accessToken\n  }\n\n  if (applications.storefrontRendererApi) {\n    const appId = applicationId('storefront-renderer')\n    tokens.storefront = fqdnSession.applications[appId]?.accessToken\n  }\n\n  if (applications.businessPlatformApi) {\n    const appId = applicationId('business-platform')\n    tokens.businessPlatform = fqdnSession.applications[appId]?.accessToken\n  }\n\n  if (applications.appManagementApi) {\n    const appId = applicationId('app-management')\n    tokens.appManagement = fqdnSession.applications[appId]?.accessToken\n  }\n\n  return tokens\n}\n\n// Scope Helpers\n/**\n * Get a flattened array of scopes for the given applications.\n *\n * @param apps - An object containing the applications we need the scopes for.\n * @returns A flattened array of scopes.\n */\nfunction getFlattenScopes(apps: OAuthApplications): string[] {\n  const admin = apps.adminApi?.scopes || []\n  const partner = apps.partnersApi?.scopes || []\n  const storefront = apps.storefrontRendererApi?.scopes || []\n  const businessPlatform = apps.businessPlatformApi?.scopes || []\n  const appManagement = apps.appManagementApi?.scopes || []\n  const requestedScopes = [...admin, ...partner, ...storefront, ...businessPlatform, ...appManagement]\n  return allDefaultScopes(requestedScopes)\n}\n\n/**\n * Get the scopes for the given applications.\n *\n * @param apps - An object containing the applications we need the scopes for.\n * @returns An object containing the scopes for each application.\n */\nfunction getExchangeScopes(apps: OAuthApplications): ExchangeScopes {\n  const adminScope = apps.adminApi?.scopes || []\n  const partnerScope = apps.partnersApi?.scopes || []\n  const storefrontScopes = apps.storefrontRendererApi?.scopes || []\n  const businessPlatformScopes = apps.businessPlatformApi?.scopes || []\n  const appManagementScopes = apps.appManagementApi?.scopes || []\n  return {\n    admin: apiScopes('admin', adminScope),\n    partners: apiScopes('partners', partnerScope),\n    storefront: apiScopes('storefront-renderer', storefrontScopes),\n    businessPlatform: apiScopes('business-platform', businessPlatformScopes),\n    appManagement: apiScopes('app-management', appManagementScopes),\n  }\n}\n\nfunction buildIdentityTokenFromEnv(\n  scopes: string[],\n  identityTokenInformation: {accessToken: string; refreshToken: string; userId: string},\n) {\n  return {\n    ...identityTokenInformation,\n    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n    scopes,\n  }\n}\n", "import {API} from '../api.js'\nimport {BugError} from '../../../public/node/error.js'\nimport {Environment, serviceEnvironment} from '../context/service.js'\n\nexport function clientId(): string {\n  const environment = serviceEnvironment()\n  if (environment === Environment.Local) {\n    return 'e5380e02-312a-7408-5718-e07017e9cf52'\n  } else if (environment === Environment.Production) {\n    return 'fbdb2649-e327-4907-8f67-908d24cfd7e3'\n  } else {\n    return 'e5380e02-312a-7408-5718-e07017e9cf52'\n  }\n}\n\nexport function applicationId(api: API): string {\n  switch (api) {\n    case 'admin': {\n      const environment = serviceEnvironment()\n      if (environment === Environment.Local) {\n        return 'e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52'\n      } else if (environment === Environment.Production) {\n        return '7ee65a63608843c577db8b23c4d7316ea0a01bd2f7594f8a9c06ea668c1b775c'\n      } else {\n        return 'e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52'\n      }\n    }\n    case 'partners': {\n      const environment = serviceEnvironment()\n      if (environment === Environment.Local) {\n        return 'df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978'\n      } else if (environment === Environment.Production) {\n        return '271e16d403dfa18082ffb3d197bd2b5f4479c3fc32736d69296829cbb28d41a6'\n      } else {\n        return 'df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978'\n      }\n    }\n    case 'storefront-renderer': {\n      const environment = serviceEnvironment()\n      if (environment === Environment.Local) {\n        return '46f603de-894f-488d-9471-5b721280ff49'\n      } else if (environment === Environment.Production) {\n        return 'ee139b3d-5861-4d45-b387-1bc3ada7811c'\n      } else {\n        return '46f603de-894f-488d-9471-5b721280ff49'\n      }\n    }\n    case 'business-platform': {\n      const environment = serviceEnvironment()\n      if (environment === Environment.Local) {\n        return 'ace6dc89-b526-456d-a942-4b8ef6acda4b'\n      } else if (environment === Environment.Production) {\n        return '32ff8ee5-82b8-4d93-9f8a-c6997cefb7dc'\n      } else {\n        return 'ace6dc89-b526-456d-a942-4b8ef6acda4b'\n      }\n    }\n    case 'app-management': {\n      const environment = serviceEnvironment()\n      if (environment === Environment.Production) {\n        return '7ee65a63608843c577db8b23c4d7316ea0a01bd2f7594f8a9c06ea668c1b775c'\n      } else {\n        return 'e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52'\n      }\n    }\n    default:\n      throw new BugError(`Application id for API of type: ${api}`)\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {applicationId} from './identity.js'\nimport {ApplicationToken, IdentityToken, validateCachedIdentityTokenStructure} from './schema.js'\nimport {validateIdentityToken} from './identity-token-validation.js'\nimport {sessionConstants} from '../constants.js'\nimport {outputDebug} from '../../../public/node/output.js'\nimport {firstPartyDev} from '../../../public/node/context/local.js'\nimport {OAuthApplications} from '../session.js'\n\ntype ValidationResult = 'needs_refresh' | 'needs_full_auth' | 'ok'\n\n/**\n * Validate if an identity token is valid for the requested scopes\n */\nfunction validateScopes(requestedScopes: string[], identity: IdentityToken) {\n  const currentScopes = identity.scopes\n  if (firstPartyDev() !== currentScopes.includes('employee')) return false\n  return requestedScopes.every((scope) => currentScopes.includes(scope))\n}\n\n/**\n * Validate if the current session is valid or we need to refresh/re-authenticate\n * @param scopes - requested scopes to validate\n * @param applications - requested applications\n * @param session - current session with identity and application tokens\n * @returns 'ok' if the session is valid, 'needs_full_auth' if we need to re-authenticate, 'needs_refresh' if we need to refresh the session\n */\nexport async function validateSession(\n  scopes: string[],\n  applications: OAuthApplications,\n  session: {\n    identity: IdentityToken\n    applications: {[x: string]: ApplicationToken}\n  },\n): Promise<ValidationResult> {\n  if (!session) return 'needs_full_auth'\n  const scopesAreValid = validateScopes(scopes, session.identity)\n  const identityIsValid = await validateIdentityToken(session.identity.accessToken)\n  if (!scopesAreValid) return 'needs_full_auth'\n  let tokensAreExpired = isTokenExpired(session.identity)\n\n  if (applications.partnersApi) {\n    const appId = applicationId('partners')\n    const token = session.applications[appId]!\n    tokensAreExpired = tokensAreExpired || isTokenExpired(token)\n  }\n\n  if (applications.appManagementApi) {\n    const appId = applicationId('app-management')\n    const token = session.applications[appId]!\n    tokensAreExpired = tokensAreExpired || isTokenExpired(token)\n  }\n\n  if (applications.storefrontRendererApi) {\n    const appId = applicationId('storefront-renderer')\n    const token = session.applications[appId]!\n    tokensAreExpired = tokensAreExpired || isTokenExpired(token)\n  }\n\n  if (applications.adminApi) {\n    const appId = applicationId('admin')\n    const realAppId = `${applications.adminApi.storeFqdn}-${appId}`\n    const token = session.applications[realAppId]!\n    tokensAreExpired = tokensAreExpired || isTokenExpired(token)\n  }\n\n  outputDebug(`\nThe validation of the token for application/identity completed with the following results:\n- It's expired: ${tokensAreExpired}\n- It's invalid in identity: ${!identityIsValid}\n  `)\n\n  if (!validateCachedIdentityTokenStructure(session.identity)) {\n    return 'needs_full_auth'\n  }\n\n  if (tokensAreExpired) return 'needs_refresh'\n  if (!identityIsValid) return 'needs_full_auth'\n  return 'ok'\n}\n\nfunction isTokenExpired(token: ApplicationToken): boolean {\n  if (!token) return true\n  return token.expiresAt < expireThreshold()\n}\n\nfunction expireThreshold(): Date {\n  return new Date(Date.now() + sessionConstants.expirationTimeMarginInMinutes * 60 * 1000)\n}\n", "import {zod} from '../../../public/node/schema.js'\n\nconst DateSchema = zod.preprocess((arg) => {\n  if (typeof arg === 'string' || arg instanceof Date) return new Date(arg)\n  return null\n}, zod.date())\n\n/**\n * The schema represents an Identity token.\n */\nconst IdentityTokenSchema = zod.object({\n  accessToken: zod.string(),\n  refreshToken: zod.string(),\n  expiresAt: DateSchema,\n  scopes: zod.array(zod.string()),\n  userId: zod.string(),\n})\n\n/**\n * The schema represents an application token.\n */\nconst ApplicationTokenSchema = zod.object({\n  accessToken: zod.string(),\n  expiresAt: DateSchema,\n  scopes: zod.array(zod.string()),\n})\n\n/**\n * This schema represents the format of the session\n * that we cache in the system to avoid unnecessary\n * token exchanges.\n *\n * @example\n * ```\n * {\n *    \"accounts.shopify.com\": {\n *      \"identity\": {...} // IdentityTokenSchema\n *      \"applications\": {\n *        \"${domain}-application-id\": {  // Admin APIs includes domain in the key\n *          \"accessToken\": \"...\",\n *        },\n *        \"$application-id\": { // ApplicationTokenSchema\n *          \"accessToken\": \"...\",\n *        },\n *      }\n *    },\n *    \"identity.spin.com\": {...}\n * }\n * ```\n */\nexport const SessionSchema = zod.object({}).catchall(\n  zod.object({\n    /**\n     * It contains the identity token. Before usint it, we exchange it\n     * to get a token that we can use with different applications. The exchanged\n     * tokens for the applications are stored under applications.\n     */\n    identity: IdentityTokenSchema,\n    /**\n     * It contains exchanged tokens for the applications the CLI\n     * authenticates with. Tokens are scoped under the fqdn of the applications.\n     */\n    applications: zod.object({}).catchall(ApplicationTokenSchema),\n  }),\n)\n\nexport type Session = zod.infer<typeof SessionSchema>\nexport type IdentityToken = zod.infer<typeof IdentityTokenSchema>\nexport type ApplicationToken = zod.infer<typeof ApplicationTokenSchema>\n\n/**\n * Confirms that a given identity token structure matches what the schema currently defines.\n *\n * A full re-auth is the expectation if this validation fails.\n */\nexport function validateCachedIdentityTokenStructure(identityToken: unknown) {\n  const parsed = IdentityTokenSchema.safeParse(identityToken)\n  return parsed.success\n}\n", "import {identityFqdn} from '../../../public/node/context/fqdn.js'\nimport {outputDebug} from '../../../public/node/output.js'\nimport {shopifyFetch} from '../../../public/node/http.js'\nimport {cacheRetrieveOrRepopulate, IntrospectionUrlKey} from '../conf-store.js'\nimport {err, ok, Result} from '../../../public/node/result.js'\nimport {AbortError} from '../../../public/node/error.js'\nimport {firstPartyDev} from '@shopify/cli-kit/node/context/local'\nimport {isSpin} from '@shopify/cli-kit/node/context/spin'\n\nexport async function validateIdentityToken(token: string): Promise<boolean> {\n  if (isSpin() && firstPartyDev()) return true\n\n  try {\n    return withIntrospectionURL<boolean>(async (introspectionURL: string) => {\n      const options = {\n        method: 'POST',\n        headers: {Authorization: `Bearer ${token}`, 'Content-Type': 'application/json'},\n        body: JSON.stringify({token}),\n      }\n      outputDebug(`Sending Identity Introspection request to URL: ${introspectionURL}`)\n\n      const response = await shopifyFetch(introspectionURL, options)\n\n      if (response.ok && response.headers.get('content-type')?.includes('json')) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const json: any = await response.json()\n        outputDebug(`The identity token is valid: ${json.valid}`)\n        return ok(json.valid)\n      } else if (response.status === 404 || response.status > 500) {\n        // If the status is 404 or 5xx, most likely the introspection endpoint\n        // has changed. We should invalidate the cache and try again.\n        return err(new AbortError(`The introspection endpoint returned a ${response.status}: ${introspectionURL}`))\n      } else {\n        const text = await response.text()\n        outputDebug(`The Introspection request failed with:\n - status: ${response.status}\n - www-authenticate header: ${JSON.stringify(response.headers.get('www-authenticate'))}\n - body: ${JSON.stringify(text)}`)\n        return ok(false)\n      }\n    })\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch (error) {\n    outputDebug(`The identity token is invalid: ${error}`)\n    return false\n  }\n}\n\nasync function withIntrospectionURL<T>(fn: (introspectionUrl: string) => Promise<Result<T, AbortError>>): Promise<T> {\n  const week = 7 * 24 * 60 * 60 * 1000\n  const cacheKey: IntrospectionUrlKey = `identity-introspection-url-${await identityFqdn()}`\n  let introspectionURL = await cacheRetrieveOrRepopulate(cacheKey, getIntrospectionURL, week)\n  let result: Result<T, AbortError> = await fn(introspectionURL)\n  if (result.isErr()) {\n    introspectionURL = await cacheRetrieveOrRepopulate(cacheKey, getIntrospectionURL, 0)\n    result = await fn(introspectionURL)\n  }\n  if (result.isErr()) {\n    throw result.error\n  } else {\n    return result.value\n  }\n}\n\nasync function getIntrospectionURL(): Promise<string> {\n  const response = await shopifyFetch(`https://${await identityFqdn()}/.well-known/openid-configuration.json`)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const json: any = await response.json()\n  return json.introspection_endpoint\n}\n", "import {spinFqdn} from './spin.js'\nimport {AbortError} from '../error.js'\nimport {serviceEnvironment} from '../../../private/node/context/service.js'\nimport {DevServer, DevServerCore} from '../vendor/dev_server/DevServer.js'\n\nexport const CouldntObtainPartnersSpinFQDNError = new AbortError(\n  \"Couldn't obtain the Spin FQDN for Partners when the CLI is not running from a Spin environment.\",\n)\nexport const CouldntObtainIdentitySpinFQDNError = new AbortError(\n  \"Couldn't obtain the Spin FQDN for Identity when the CLI is not running from a Spin environment.\",\n)\nexport const CouldntObtainShopifySpinFQDNError = new AbortError(\n  \"Couldn't obtain the Spin FQDN for Shopify when the CLI is not running from a Spin environment.\",\n)\nexport const NotProvidedStoreFQDNError = new AbortError(\n  \"Couldn't obtain the Shopify FQDN because the store FQDN was not provided.\",\n)\n\n/**\n * It returns the Partners' API service we should interact with.\n *\n * @returns Fully-qualified domain of the partners service we should interact with.\n */\nexport async function partnersFqdn(): Promise<string> {\n  const environment = serviceEnvironment()\n  const productionFqdn = 'partners.shopify.com'\n  switch (environment) {\n    case 'local':\n      return new DevServer('partners').host()\n    case 'spin':\n      return `partners.${await spinFqdn()}`\n    default:\n      return productionFqdn\n  }\n}\n\n/**\n * It returns the App Management API service we should interact with.\n *\n * @returns Fully-qualified domain of the App Management service we should interact with.\n */\nexport async function appManagementFqdn(): Promise<string> {\n  const environment = serviceEnvironment()\n  const productionFqdn = 'app.shopify.com'\n  switch (environment) {\n    case 'local':\n      return new DevServerCore().host('app')\n    case 'spin':\n      return `app.shopify.${await spinFqdn()}`\n    default:\n      return productionFqdn\n  }\n}\n\n/**\n * It returns the Developer Dashboard domain we should interact with.\n *\n * @returns Fully-qualified domain of the Developer Dashboard we should interact with.\n */\nexport async function developerDashboardFqdn(): Promise<string> {\n  const environment = serviceEnvironment()\n  const productionFqdn = 'dev.shopify.com'\n  switch (environment) {\n    case 'local':\n      return new DevServerCore().host('dev')\n    case 'spin':\n      return `dev.shopify.${await spinFqdn()}`\n    default:\n      return productionFqdn\n  }\n}\n\n/**\n * It returns the BusinessPlatform' API service we should interact with.\n *\n * @returns Fully-qualified domain of the partners service we should interact with.\n */\nexport async function businessPlatformFqdn(): Promise<string> {\n  const environment = serviceEnvironment()\n  const productionFqdn = 'destinations.shopifysvc.com'\n  switch (environment) {\n    case 'local':\n      return new DevServer('business-platform').host()\n    case 'spin':\n      return `business-platform.${await spinFqdn()}`\n    default:\n      return productionFqdn\n  }\n}\n\n/**\n * It returns the Identity service we should interact with.\n *\n * @returns Fully-qualified domain of the Identity service we should interact with.\n */\nexport async function identityFqdn(): Promise<string> {\n  const environment = serviceEnvironment()\n  const productionFqdn = 'accounts.shopify.com'\n  switch (environment) {\n    case 'local':\n      return new DevServer('identity').host()\n    case 'spin':\n      return `identity.${await spinFqdn()}`\n    default:\n      return productionFqdn\n  }\n}\n\n/**\n * Normalize the store name to be used in the CLI.\n * It will add the .myshopify.com domain if it's not present.\n * It will add the spin domain if it's not present and we're in a Spin environment.\n *\n * @param store - Store name.\n * @returns Normalized store name.\n */\nexport async function normalizeStoreFqdn(store: string): Promise<string> {\n  const storeFqdn = store.replace(/^https?:\\/\\//, '').replace(/\\/$/, '')\n  const addDomain = async (storeFqdn: string) => {\n    switch (serviceEnvironment()) {\n      case 'local':\n        return new DevServerCore().host(storeFqdn)\n      case 'spin':\n        return `${storeFqdn}.shopify.${await spinFqdn()}`\n      default:\n        return `${storeFqdn}.myshopify.com`\n    }\n  }\n  const containDomain = (storeFqdn: string) =>\n    storeFqdn.includes('.myshopify.com') ||\n    storeFqdn.includes('spin.dev') ||\n    storeFqdn.includes('shopify.io') ||\n    storeFqdn.includes('.shop.dev')\n  return containDomain(storeFqdn) ? storeFqdn : addDomain(storeFqdn)\n}\n", "import fs from 'fs';\nimport * as os from 'os';\nimport * as ni from 'network-interfaces';\nimport { execSync } from 'child_process';\n\nclass DevServerUtils {\n  static readonly INFERENCE_MODE_SENTINEL =\n    '/opt/dev/misc/dev-server-inference-mode';\n  static readonly BACKEND_PORT = 8080;\n  static readonly CONNECT_TIMEOUT = 100; // 100ms\n  static readonly HOSTS_FILE = '/etc/hosts';\n\n  static assertConnectable(name: string, addr: string, port: number): void {\n    try {\n      execSync(`nc -z -v -w 1 ${addr} ${port}`, {\n        timeout: DevServerUtils.CONNECT_TIMEOUT,\n        stdio: 'ignore',\n      });\n    } catch (err) {\n      throw new Error(\n        `NET FAILED DevServer for '${name}' is not running on ${port} / ${addr}: \\`dev up ${name}\\` to start it.`\n      );\n    }\n  }\n\n  static inferenceModeAndProjectIsEdition2016(name: string): boolean {\n    try {\n      fs.accessSync(DevServerUtils.INFERENCE_MODE_SENTINEL);\n      try {\n        fs.accessSync(`/opt/nginx/etc/manifest/${name}/current/edition-2024`);\n        return false;\n      } catch {\n        return true;\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  static getIpFromHosts(hostname: string): string {\n    try {\n      const hostsContent = fs.readFileSync(DevServerUtils.HOSTS_FILE, 'utf8');\n      const lines = hostsContent.split(/\\r?\\n/);\n      for (const line of lines) {\n        const matches = /^\\s*?([^#]+?)\\s+([^#]+?)$/.exec(line);\n        if (matches && matches.length === 3 && matches[2] === hostname) {\n          return matches[1]!; // Return the IP address\n        }\n      }\n    } catch (error) {\n      console.error('Error reading hosts file:', error);\n    }\n\n    throw new Error(`No IP found for hostname: ${hostname}`);\n  }\n\n  static getAddrPort2024(name: string): [string, number] {\n    try {\n      const backendIp = DevServerUtils.resolveBackendHost(name);\n      const interfaceName = ni.fromIp(backendIp, {\n        internal: true,\n        ipVersion: 4,\n      });\n      return [backendIp, DevServerUtils.BACKEND_PORT];\n    } catch (error) {\n      throw new Error(\n        `DevServer for '${name}' is not running: \\`dev up ${name}\\` to start it.`\n      );\n    }\n  }\n\n  static getAddrPort2016(name: string): [string, number] {\n    try {\n      const portContent = fs.readFileSync(\n        `${os.homedir()}/.local/run/services/${name}/server/port`,\n        'utf-8'\n      );\n      return ['localhost', parseInt(portContent, 10)];\n    } catch (error) {\n      throw new Error(\n        `DevServer for '${name}' is not running: \\`dev up ${name}\\` to start it.`\n      );\n    }\n  }\n\n  static resolveBackendHost(name: string): string {\n    let host: string;\n    try {\n      host = fs.readlinkSync(`/opt/nginx/etc/manifest/${name}/current`);\n    } catch (error) {\n      host = `${name}.root.shopify.dev.internal`;\n    }\n\n    try {\n      return DevServerUtils.getIpFromHosts(host);\n    } catch {\n      return host;\n    }\n  }\n}\n\nexport class DevServer {\n  protected name: string;\n\n  constructor(name: string) {\n    if (!process.env.SPIN && !process.env.USING_DEV) {\n      throw new Error('DevServer is not supported in this environment');\n    }\n\n    if (name === 'shopify') {\n      throw new Error('Use DevServer.core for the \\'shopify\\' project');\n    }\n    this.name = name;\n  }\n\n  url({\n    nonstandardHostPrefix,\n  }: { nonstandardHostPrefix?: string } = {}): string {\n    return `https://${this.host({nonstandardHostPrefix})}`;\n  }\n\n  host({\n    nonstandardHostPrefix,\n  }: { nonstandardHostPrefix?: string } = {}): string {\n    const prefix = nonstandardHostPrefix || this.name;\n\n    if (process.env.SPIN === '1') {\n      const services = fs.readdirSync('/run/ports2')\n        .filter(file => file.endsWith(`--${this.name}`));\n\n      if (services.length === 0) {\n        throw new Error(\n          `DevServer for '${this.name}' not present in this spin environment`\n        );\n      }\n\n      const match = new RegExp(`^(.+)${this.name}$`).exec(services[0]!);\n      const organization = match ? match[1] : '';\n      const spinPrefix = organization !== 'shopify--' ? `${organization}` : '';\n\n      return `${spinPrefix}${this.name}.${process.env.SPIN_FQDN}`;\n    } else if (DevServerUtils.inferenceModeAndProjectIsEdition2016(this.name)) {\n      this.assertRunningLocally2016();\n      return `${prefix}.myshopify.io`;\n    } else {\n      this.assertRunningLocally2024();\n      return `${prefix}.shop.dev`;\n    }\n  }\n\n  protected assertRunningLocally2024(): void {\n    const [addr, port] = DevServerUtils.getAddrPort2024(this.name);\n    DevServerUtils.assertConnectable(this.name, addr, port);\n  }\n\n  protected assertRunningLocally2016(): void {\n    const [addr, port] = DevServerUtils.getAddrPort2016(this.name);\n    DevServerUtils.assertConnectable(this.name, addr, port);\n  }\n}\n\nexport class DevServerCore {\n  private readonly name = 'shopify';\n\n  url(prefix: string): string {\n    return `https://${this.host(prefix)}`;\n  }\n\n  host(prefix: string): string {\n    if (process.env.SPIN === '1') {\n      const projectPortRoot = fs\n        .readdirSync('/run/ports2')\n        .find((file) => file.endsWith(`--${this.name}`));\n      if (!projectPortRoot) {\n        throw new Error(\n          `DevServer for '${this.name}' not present in this spin environment`\n        );\n      }\n      // Spin mostly doesn't do alternative hostname prefixing.\n      return `${prefix}.${this.name}.${process.env.SPIN_FQDN}`;\n    } else if (DevServerUtils.inferenceModeAndProjectIsEdition2016('shopify')) {\n      this.assertRunningLocally2016();\n      return `${prefix}.myshopify.io`;\n    } else {\n      this.assertRunningLocally2024();\n      return `${prefix}.my.shop.dev`;\n    }\n  }\n\n  private assertRunningLocally2024(): void {\n    const [addr, port] = DevServerUtils.getAddrPort2024('shopify');\n    DevServerUtils.assertConnectable('shopify', addr, port);\n  }\n\n  private assertRunningLocally2016(): void {\n    const [addr, port] = DevServerUtils.getAddrPort2016('shopify');\n    DevServerUtils.assertConnectable('shopify', addr, port);\n  }\n}", "import {FatalError, AbortError, ExtendableError} from './error.js'\n\nexport type Result<TValue, TError> = Ok<TValue, TError> | Err<TValue, TError>\n\n/**\n * Utility metho to create an `Ok` result from a `value`\n *\n * @param value - `value` used to crete the `Result`\n * @returns an instance of a `Ok` `Result` inferring its type\n */\nexport const ok = <TValue, TError = never>(value: TValue): Ok<TValue, TError> => new Ok(value)\n\n/**\n * Utility method to create an `Error` result from an `error`\n *\n * @param err - `error` used to crete the `Result`\n * @returns an instance of an `Error` `Result` inferring its type\n */\nexport const err = <TValue = never, TError = unknown>(err: TError): Err<TValue, TError> => new Err(err)\n\nexport class Ok<TValue, TError> {\n  constructor(readonly value: TValue) {}\n\n  /**\n   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`\n   *\n   * @returns `false` as the `Resul` is `OK`\n   */\n  isErr(): this is Err<TValue, TError> {\n    return false\n  }\n\n  /**\n   * Runs the `handler` method an return the same an unaltered copy of the `Result`. It could be used to log an\n   * output when the result is `Ok` without breaking the flow\n   *\n   * @param handler - method to be run when the result is `Ok`\n   * @returns a copy of the same `Result`\n   */\n  doOnOk(handler: (value: TValue) => void): Result<TValue, TError> {\n    handler(this.value)\n    return ok(this.value)\n  }\n\n  /**\n   * A safe mode to throw the `error` of the `Result`\n   */\n  valueOrBug(): TValue {\n    return this.value\n  }\n\n  /**\n   * Throws an abort error if the result doesn't represent a value.\n   */\n  valueOrAbort(): TValue {\n    return this.value\n  }\n\n  /**\n   * Maps the value to another one with a different type. It leaves the `Error` type unaltered\n   *\n   * @param mapper - The mapper method to apply an `OK` value\n   * @returns a new result with the new mapped value\n   */\n  map<TMappedValue>(mapper: (value: TValue) => TMappedValue): Result<TMappedValue, TError> {\n    return ok(mapper(this.value))\n  }\n\n  /**\n   * Maps the error type to another one. It leaves the `Ok` type and value unaltered\n   *\n   * @param _mapper - This mapper method is not used for an `Ok` value\n   * @returns a new result with the new mapped error type and an value\n   */\n  mapError<TMappedError>(_mapper: (error: TError) => TMappedError): Result<TValue, TMappedError> {\n    return ok(this.value)\n  }\n}\n\nexport class Err<TValue, TError> {\n  // eslint-disable-next-line node/handle-callback-err\n  constructor(readonly error: TError) {}\n\n  /**\n   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`\n   *\n   * @returns `false` as the `Resul` is `OK`\n   */\n  isErr(): this is Err<TValue, TError> {\n    return true\n  }\n\n  /**\n   * Return an unaltered copy of the `Error` without doing anything.\n   *\n   * @param _handler - This handler method is not used for an `Error`\n   * @returns a copy of the same `Error`\n   */\n  doOnOk(_handler: (value: TValue) => void): Result<TValue, TError> {\n    return err(this.error)\n  }\n\n  /**\n   * A safe mode to throw the `error` of the `Result`\n   */\n  valueOrBug(): TValue {\n    throw this.error\n  }\n\n  /**\n   * Throws an abort error if the result doesn't represent a value.\n   */\n  valueOrAbort(): TValue {\n    if (this.error instanceof FatalError) {\n      throw this.error\n    } else if (this.error instanceof ExtendableError || this.error instanceof Error) {\n      const error = new AbortError(this.error.message)\n      error.stack = this.error.stack\n      throw error\n    } else {\n      throw new AbortError(`${this.error}`)\n    }\n  }\n\n  /**\n   * Maps the value type to another one. It leaves the `Error` unaltered\n   *\n   * @param _mapper - This mapper method is not used for an `Error` value\n   * @returns a new result with the new value type and an unaltered error\n   */\n  map<TMappedValue>(_mapper: (valueOrBug: TValue) => TMappedValue): Result<TMappedValue, TError> {\n    return err(this.error)\n  }\n\n  /**\n   * Maps the error to another one with a different type. It leaves the value type unaltered\n   *\n   * @param mapper - The mapper method to apply an `Error` value\n   * @returns a new result with the new mapped error\n   */\n  mapError<TMappedError>(mapper: (error: TError) => TMappedError): Result<TValue, TMappedError> {\n    return err(mapper(this.error))\n  }\n}\n", "import {allAPIs, API} from '../api.js'\nimport {BugError} from '../../../public/node/error.js'\n\n/**\n * Generate a flat array with all the default scopes for all the APIs plus\n * any custom scope defined by the user.\n * @param extraScopes - custom user-defined scopes\n * @returns Array of scopes\n */\nexport function allDefaultScopes(extraScopes: string[] = []): string[] {\n  let scopes = allAPIs.map((api) => defaultApiScopes(api)).flat()\n  scopes = ['openid', ...scopes, ...extraScopes].map(scopeTransform)\n  return Array.from(new Set(scopes))\n}\n\n/**\n * Generate a flat array with the default scopes for the given API plus\n * any custom scope defined by the user\n * @param api - API to get the scopes for\n * @param extraScopes - custom user-defined scopes\n * @returns Array of scopes\n */\nexport function apiScopes(api: API, extraScopes: string[] = []): string[] {\n  const scopes = [...defaultApiScopes(api), ...extraScopes.map(scopeTransform)].map(scopeTransform)\n  return Array.from(new Set(scopes))\n}\n\nfunction defaultApiScopes(api: API): string[] {\n  switch (api) {\n    case 'admin':\n      return ['graphql', 'themes', 'collaborator']\n    case 'storefront-renderer':\n      return ['devtools']\n    case 'partners':\n      return ['cli']\n    case 'business-platform':\n      return ['destinations', 'store-management']\n    case 'app-management':\n      return ['app-management']\n    default:\n      throw new BugError(`Unknown API: ${api}`)\n  }\n}\n\nfunction scopeTransform(scope: string): string {\n  switch (scope) {\n    case 'graphql':\n      return 'https://api.shopify.com/auth/shop.admin.graphql'\n    case 'themes':\n      return 'https://api.shopify.com/auth/shop.admin.themes'\n    case 'collaborator':\n      return 'https://api.shopify.com/auth/partners.collaborator-relationships.readonly'\n    case 'cli':\n      return 'https://api.shopify.com/auth/partners.app.cli.access'\n    case 'devtools':\n      return 'https://api.shopify.com/auth/shop.storefront-renderer.devtools'\n    case 'destinations':\n      return 'https://api.shopify.com/auth/destinations.readonly'\n    case 'store-management':\n      return 'https://api.shopify.com/auth/organization.store-management'\n    case 'app-management':\n      return 'https://api.shopify.com/auth/organization.apps.manage'\n    default:\n      return scope\n  }\n}\n", "import {ApplicationToken, IdentityToken} from './schema.js'\nimport {applicationId, clientId as getIdentityClientId} from './identity.js'\nimport {API} from '../api.js'\nimport {identityFqdn} from '../../../public/node/context/fqdn.js'\nimport {shopifyFetch} from '../../../public/node/http.js'\nimport {err, ok, Result} from '../../../public/node/result.js'\nimport {AbortError, BugError, ExtendableError} from '../../../public/node/error.js'\nimport {isAppManagementDisabled} from '../../../public/node/context/local.js'\nimport {setLastSeenAuthMethod, setLastSeenUserIdAfterAuth} from '../session.js'\nimport * as jose from 'jose'\nimport {nonRandomUUID} from '@shopify/cli-kit/node/crypto'\n\nexport class InvalidGrantError extends ExtendableError {}\nexport class InvalidRequestError extends ExtendableError {}\nclass InvalidTargetError extends AbortError {}\n\nexport interface ExchangeScopes {\n  admin: string[]\n  partners: string[]\n  storefront: string[]\n  businessPlatform: string[]\n  appManagement: string[]\n}\n\n/**\n * Given an identity token, request an application token.\n * @param identityToken - access token obtained in a previous step\n * @param store - the store to use, only needed for admin API\n * @returns An array with the application access tokens.\n */\nexport async function exchangeAccessForApplicationTokens(\n  identityToken: IdentityToken,\n  scopes: ExchangeScopes,\n  store?: string,\n): Promise<{[x: string]: ApplicationToken}> {\n  const token = identityToken.accessToken\n\n  const [partners, storefront, businessPlatform, admin, appManagement] = await Promise.all([\n    requestAppToken('partners', token, scopes.partners),\n    requestAppToken('storefront-renderer', token, scopes.storefront),\n    requestAppToken('business-platform', token, scopes.businessPlatform),\n    store ? requestAppToken('admin', token, scopes.admin, store) : {},\n    isAppManagementDisabled() ? {} : requestAppToken('app-management', token, scopes.appManagement),\n  ])\n\n  return {\n    ...partners,\n    ...storefront,\n    ...businessPlatform,\n    ...admin,\n    ...appManagement,\n  }\n}\n\n/**\n * Given an expired access token, refresh it to get a new one.\n */\nexport async function refreshAccessToken(currentToken: IdentityToken): Promise<IdentityToken> {\n  const clientId = getIdentityClientId()\n  const params = {\n    grant_type: 'refresh_token',\n    access_token: currentToken.accessToken,\n    refresh_token: currentToken.refreshToken,\n    client_id: clientId,\n  }\n  const tokenResult = await tokenRequest(params)\n  const value = tokenResult.mapError(tokenRequestErrorHandler).valueOrBug()\n  return buildIdentityToken(value, currentToken.userId)\n}\n\n/**\n * Given a custom CLI token passed as ENV variable, request a valid partners API token\n * This token does not accept extra scopes, just the cli one.\n * @param token - The CLI token passed as ENV variable\n * @returns An instance with the application access tokens.\n */\nexport async function exchangeCustomPartnerToken(token: string): Promise<{accessToken: string; userId: string}> {\n  const appId = applicationId('partners')\n  try {\n    const newToken = await requestAppToken('partners', token, ['https://api.shopify.com/auth/partners.app.cli.access'])\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const accessToken = newToken[appId]!.accessToken\n    const userId = nonRandomUUID(token)\n    setLastSeenUserIdAfterAuth(userId)\n    setLastSeenAuthMethod('partners_token')\n    return {accessToken, userId}\n  } catch (error) {\n    throw new AbortError('The custom token provided is invalid.', 'Ensure the token is correct and not expired.')\n  }\n}\n\ntype IdentityDeviceError = 'authorization_pending' | 'access_denied' | 'expired_token' | 'slow_down' | 'unknown_failure'\n\n/**\n * Given a deviceCode obtained after starting a device identity flow, request an identity token.\n * @param deviceCode - The device code obtained after starting a device identity flow\n * @param scopes - The scopes to request\n * @returns An instance with the identity access tokens.\n */\nexport async function exchangeDeviceCodeForAccessToken(\n  deviceCode: string,\n): Promise<Result<IdentityToken, IdentityDeviceError>> {\n  const clientId = await getIdentityClientId()\n\n  const params = {\n    grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n    device_code: deviceCode,\n    client_id: clientId,\n  }\n\n  const tokenResult = await tokenRequest(params)\n  if (tokenResult.isErr()) {\n    return err(tokenResult.error as IdentityDeviceError)\n  }\n  const identityToken = buildIdentityToken(tokenResult.value)\n  return ok(identityToken)\n}\n\nasync function requestAppToken(\n  api: API,\n  token: string,\n  scopes: string[] = [],\n  store?: string,\n): Promise<{[x: string]: ApplicationToken}> {\n  const appId = applicationId(api)\n  const clientId = await getIdentityClientId()\n\n  const params = {\n    grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',\n    requested_token_type: 'urn:ietf:params:oauth:token-type:access_token',\n    subject_token_type: 'urn:ietf:params:oauth:token-type:access_token',\n    client_id: clientId,\n    audience: appId,\n    scope: scopes.join(' '),\n    subject_token: token,\n    ...(api === 'admin' && {destination: `https://${store}/admin`}),\n  }\n\n  let identifier = appId\n  if (api === 'admin' && store) {\n    identifier = `${store}-${appId}`\n  }\n  const tokenResult = await tokenRequest(params)\n  const value = tokenResult.mapError(tokenRequestErrorHandler).valueOrBug()\n  const appToken = buildApplicationToken(value)\n  return {[identifier]: appToken}\n}\n\ninterface TokenRequestResult {\n  access_token: string\n  expires_in: number\n  refresh_token: string\n  scope: string\n  id_token?: string\n}\n\nfunction tokenRequestErrorHandler(error: string) {\n  const invalidTargetErrorMessage =\n    'You are not authorized to use the CLI to develop in the provided store.' +\n    '\\n\\n' +\n    \"You can't use Shopify CLI with development stores if you only have Partner \" +\n    'staff member access. If you want to use Shopify CLI to work on a development store, then ' +\n    'you should be the store owner or create a staff account on the store.' +\n    '\\n\\n' +\n    \"If you're the store owner, then you need to log in to the store directly using the \" +\n    'store URL at least once before you log in using Shopify CLI.' +\n    'Logging in to the Shopify admin directly connects the development ' +\n    'store with your Shopify login.'\n  if (error === 'invalid_grant') {\n    // There's an scenario when Identity returns \"invalid_grant\" when trying to refresh the token\n    // using a valid refresh token. When that happens, we take the user through the authentication flow.\n    return new InvalidGrantError()\n  }\n  if (error === 'invalid_request') {\n    // There's an scenario when Identity returns \"invalid_request\" when exchanging an identity token.\n    // This means the token is invalid. We clear the session and throw an error to let the caller know.\n    return new InvalidRequestError()\n  }\n  if (error === 'invalid_target') {\n    return new InvalidTargetError(invalidTargetErrorMessage)\n  }\n  // eslint-disable-next-line @shopify/cli/no-error-factory-functions\n  return new AbortError(error)\n}\n\nasync function tokenRequest(params: {[key: string]: string}): Promise<Result<TokenRequestResult, string>> {\n  const fqdn = await identityFqdn()\n  const url = new URL(`https://${fqdn}/oauth/token`)\n  url.search = new URLSearchParams(Object.entries(params)).toString()\n  const res = await shopifyFetch(url.href, {method: 'POST'})\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const payload: any = await res.json()\n\n  if (res.ok) return ok(payload)\n  return err(payload.error)\n}\n\nfunction buildIdentityToken(result: TokenRequestResult, existingUserId?: string): IdentityToken {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const userId = existingUserId ?? (result.id_token ? jose.decodeJwt(result.id_token).sub! : undefined)\n\n  if (!userId) {\n    throw new BugError('Error setting userId for session. No id_token or pre-existing user ID provided.')\n  }\n\n  return {\n    accessToken: result.access_token,\n    refreshToken: result.refresh_token,\n    expiresAt: new Date(Date.now() + result.expires_in * 1000),\n    scopes: result.scope.split(' '),\n    userId,\n  }\n}\n\nfunction buildApplicationToken(result: TokenRequestResult): ApplicationToken {\n  return {\n    accessToken: result.access_token,\n    expiresAt: new Date(Date.now() + result.expires_in * 1000),\n    scopes: result.scope.split(' '),\n  }\n}\n", "export { compactDecrypt } from './jwe/compact/decrypt.js';\nexport { flattenedDecrypt } from './jwe/flattened/decrypt.js';\nexport { generalDecrypt } from './jwe/general/decrypt.js';\nexport { GeneralEncrypt } from './jwe/general/encrypt.js';\nexport { compactVerify } from './jws/compact/verify.js';\nexport { flattenedVerify } from './jws/flattened/verify.js';\nexport { generalVerify } from './jws/general/verify.js';\nexport { jwtVerify } from './jwt/verify.js';\nexport { jwtDecrypt } from './jwt/decrypt.js';\nexport { CompactEncrypt } from './jwe/compact/encrypt.js';\nexport { FlattenedEncrypt } from './jwe/flattened/encrypt.js';\nexport { CompactSign } from './jws/compact/sign.js';\nexport { FlattenedSign } from './jws/flattened/sign.js';\nexport { GeneralSign } from './jws/general/sign.js';\nexport { SignJWT } from './jwt/sign.js';\nexport { EncryptJWT } from './jwt/encrypt.js';\nexport { calculateJwkThumbprint, calculateJwkThumbprintUri } from './jwk/thumbprint.js';\nexport { EmbeddedJWK } from './jwk/embedded.js';\nexport { createLocalJWKSet } from './jwks/local.js';\nexport { createRemoteJWKSet, jwksCache, experimental_jwksCache } from './jwks/remote.js';\nexport { UnsecuredJWT } from './jwt/unsecured.js';\nexport { exportPKCS8, exportSPKI, exportJWK } from './key/export.js';\nexport { importSPKI, importPKCS8, importX509, importJWK } from './key/import.js';\nexport { decodeProtectedHeader } from './util/decode_protected_header.js';\nexport { decodeJwt } from './util/decode_jwt.js';\nexport * as errors from './util/errors.js';\nexport { generateKeyPair } from './key/generate_key_pair.js';\nexport { generateSecret } from './key/generate_secret.js';\nexport * as base64url from './util/base64url.js';\nexport { default as cryptoRuntime } from './util/runtime.js';\n", "import { Buffer } from 'node:buffer';\nimport { decoder } from '../lib/buffer_utils.js';\nfunction normalize(input) {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    return encoded;\n}\nconst encode = (input) => Buffer.from(input).toString('base64url');\nexport const decodeBase64 = (input) => new Uint8Array(Buffer.from(input, 'base64'));\nexport const encodeBase64 = (input) => Buffer.from(input).toString('base64');\nexport { encode };\nexport const decode = (input) => new Uint8Array(Buffer.from(normalize(input), 'base64url'));\n", "import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n", "export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n", "function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n", "import * as base64url from '../runtime/base64url.js';\nexport const encode = base64url.encode;\nexport const decode = base64url.decode;\n", "import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = base64url(payload);\n    }\n    catch {\n        throw new JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n", "import {SessionSchema} from './schema.js'\nimport {getSession, removeSession, setSession} from '../conf-store.js'\nimport type {Session} from './schema.js'\n\n/**\n * Serializes the session as a JSON and stores it securely in the system.\n * If the secure store is not available, the session is stored in the local config.\n * @param session - the session to store.\n */\nexport async function store(session: Session) {\n  const jsonSession = JSON.stringify(session)\n  setSession(jsonSession)\n}\n\n/**\n * Fetches the session from the secure store and returns it.\n * If the secure store is not available, the session is fetched from the local config.\n * If the format of the session is invalid, the method will discard it.\n * In the future might add some logic for supporting migrating the schema\n * of already-persisted sessions.\n * @returns Returns a promise that resolves with the session if it exists and is valid.\n */\nexport async function fetch(): Promise<Session | undefined> {\n  const content = getSession()\n\n  if (!content) {\n    return undefined\n  }\n  const contentJson = JSON.parse(content)\n  const parsedSession = await SessionSchema.safeParseAsync(contentJson)\n  if (parsedSession.success) {\n    return parsedSession.data\n  } else {\n    await remove()\n    return undefined\n  }\n}\n\n/**\n * Removes a session from the system.\n */\nexport async function remove() {\n  removeSession()\n}\n", "import {clientId} from './identity.js'\nimport {exchangeDeviceCodeForAccessToken} from './exchange.js'\nimport {IdentityToken} from './schema.js'\nimport {identityFqdn} from '../../../public/node/context/fqdn.js'\nimport {shopifyFetch} from '../../../public/node/http.js'\nimport {outputContent, outputDebug, outputInfo, outputToken} from '../../../public/node/output.js'\nimport {AbortError, BugError} from '../../../public/node/error.js'\nimport {isCloudEnvironment} from '../../../public/node/context/local.js'\nimport {openURL} from '../../../public/node/system.js'\nimport {isTTY, keypress} from '../../../public/node/ui.js'\n\nexport interface DeviceAuthorizationResponse {\n  deviceCode: string\n  userCode: string\n  verificationUri: string\n  expiresIn: number\n  verificationUriComplete?: string\n  interval?: number\n}\n\n/**\n * Initiate a device authorization flow.\n * This will return a DeviceAuthorizationResponse containing the URL where user\n * should go to authorize the device without the need of a callback to the CLI.\n *\n * Also returns a `deviceCode` used for polling the token endpoint in the next step.\n *\n * @param scopes - The scopes to request\n * @returns An object with the device authorization response.\n */\nexport async function requestDeviceAuthorization(scopes: string[]): Promise<DeviceAuthorizationResponse> {\n  const fqdn = await identityFqdn()\n  const identityClientId = clientId()\n  const queryParams = {client_id: identityClientId, scope: scopes.join(' ')}\n  const url = `https://${fqdn}/oauth/device_authorization`\n\n  const response = await shopifyFetch(url, {\n    method: 'POST',\n    headers: {'Content-type': 'application/x-www-form-urlencoded'},\n    body: convertRequestToParams(queryParams),\n  })\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const jsonResult: any = await response.json()\n\n  outputDebug(outputContent`Received device authorization code: ${outputToken.json(jsonResult)}`)\n  if (!jsonResult.device_code || !jsonResult.verification_uri_complete) {\n    throw new BugError('Failed to start authorization process')\n  }\n\n  outputInfo('\\nTo run this command, log in to Shopify.')\n\n  if (!isTTY()) {\n    throw new AbortError(\n      'Authorization is required to continue, but the current environment does not support interactive prompts.',\n      'To resolve this, specify credentials in your environment, or run the command in an interactive environment such as your local terminal.',\n    )\n  }\n\n  outputInfo(outputContent`User verification code: ${jsonResult.user_code}`)\n  const linkToken = outputToken.link(jsonResult.verification_uri_complete)\n\n  if (isCloudEnvironment()) {\n    outputInfo(outputContent`👉 Open this link to start the auth process: ${linkToken}`)\n  } else {\n    outputInfo('👉 Press any key to open the login page on your browser')\n    await keypress()\n    await openURL(jsonResult.verification_uri_complete)\n    outputInfo(outputContent`Opened link to start the auth process: ${linkToken}`)\n  }\n\n  return {\n    deviceCode: jsonResult.device_code,\n    userCode: jsonResult.user_code,\n    verificationUri: jsonResult.verification_uri,\n    expiresIn: jsonResult.expires_in,\n    verificationUriComplete: jsonResult.verification_uri_complete,\n    interval: jsonResult.interval,\n  }\n}\n\n/**\n * Poll the Oauth token endpoint with the device code obtained from a DeviceAuthorizationResponse.\n * The endpoint will return `authorization_pending` until the user completes the auth flow in the browser.\n * Once the user completes the auth flow, the endpoint will return the identity token.\n *\n * Timeout for the polling is defined by the server and is around 600 seconds.\n *\n * @param code - The device code obtained after starting a device identity flow\n * @param interval - The interval to poll the token endpoint\n * @returns The identity token\n */\nexport async function pollForDeviceAuthorization(code: string, interval = 5): Promise<IdentityToken> {\n  let currentIntervalInSeconds = interval\n\n  return new Promise<IdentityToken>((resolve, reject) => {\n    const onPoll = async () => {\n      const result = await exchangeDeviceCodeForAccessToken(code)\n      if (!result.isErr()) {\n        resolve(result.value)\n        return\n      }\n\n      const error = result.error ?? 'unknown_failure'\n\n      outputDebug(outputContent`Polling for device authorization... status: ${error}`)\n      switch (error) {\n        case 'authorization_pending': {\n          startPolling()\n          return\n        }\n        case 'slow_down':\n          currentIntervalInSeconds += 5\n          {\n            startPolling()\n            return\n          }\n        case 'access_denied':\n        case 'expired_token':\n        case 'unknown_failure': {\n          reject(result)\n        }\n      }\n    }\n\n    const startPolling = () => {\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(onPoll, currentIntervalInSeconds * 1000)\n    }\n\n    startPolling()\n  })\n}\n\nfunction convertRequestToParams(queryParams: {client_id: string; scope: string}): string {\n  return Object.entries(queryParams)\n    .map(([key, value]) => value && `${key}=${value}`)\n    .filter((hasValue) => Boolean(hasValue))\n    .join('&')\n}\n", "import {buildHeaders} from './headers.js'\nimport {themeKitAccessDomain} from '../constants.js'\nimport {AdminSession} from '@shopify/cli-kit/node/session'\n\nexport function restRequestBody<T>(requestBody?: T) {\n  if (!requestBody) {\n    return\n  }\n  return JSON.stringify(requestBody)\n}\n\nexport function restRequestUrl(\n  session: AdminSession,\n  apiVersion: string,\n  path: string,\n  searchParams: {[name: string]: string} = {},\n) {\n  const url = new URL(\n    isThemeAccessSession(session)\n      ? `https://${themeKitAccessDomain}/cli/admin/api/${apiVersion}${path}.json`\n      : `https://${session.storeFqdn}/admin/api/${apiVersion}${path}.json`,\n  )\n  Object.entries(searchParams).forEach(([name, value]) => {\n    url.searchParams.set(name, value)\n  })\n\n  return url.toString()\n}\n\nexport function restRequestHeaders(session: AdminSession) {\n  const store = session.storeFqdn\n  const token = session.token\n  const headers = buildHeaders(session.token)\n\n  if (isThemeAccessSession(session)) {\n    headers['X-Shopify-Shop'] = store\n    headers['X-Shopify-Access-Token'] = token\n  }\n\n  return headers\n}\n\nexport function isThemeAccessSession(session: AdminSession) {\n  return session.token.startsWith('shptka_')\n}\n"],
  "mappings": "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",
  "names": ["os", "store", "storeFqdn", "err", "decode", "decode", "store", "clientId", "userId", "store", "identityFqdn", "store"]
}
