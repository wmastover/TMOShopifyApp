{
  "version": 3,
  "sources": ["../../cli-kit/src/public/node/notifications-system.ts", "../../cli-kit/src/public/node/global-context.ts"],
  "sourcesContent": ["import {versionSatisfies} from './node-package-manager.js'\nimport {renderError, renderInfo, renderWarning} from './ui.js'\nimport {getCurrentCommandId} from './global-context.js'\nimport {outputDebug} from './output.js'\nimport {zod} from './schema.js'\nimport {AbortSilentError} from './error.js'\nimport {isTruthy} from './context/utilities.js'\nimport {jsonOutputEnabled} from './environment.js'\nimport {CLI_KIT_VERSION} from '../common/version.js'\nimport {\n  NotificationKey,\n  NotificationsKey,\n  cacheRetrieve,\n  cacheRetrieveOrRepopulate,\n  cacheStore,\n} from '../../private/node/conf-store.js'\nimport {fetch} from '@shopify/cli-kit/node/http'\n\nconst URL = 'https://cdn.shopify.com/static/cli/notifications.json'\nconst CACHE_DURATION_IN_MS = 3600 * 1000\n\nfunction url(): string {\n  return process.env.SHOPIFY_CLI_NOTIFICATIONS_URL ?? URL\n}\n\nconst NotificationSchema = zod.object({\n  id: zod.string(),\n  message: zod.string(),\n  type: zod.enum(['info', 'warning', 'error']),\n  frequency: zod.enum(['always', 'once', 'once_a_day', 'once_a_week']),\n  ownerChannel: zod.string(),\n  cta: zod\n    .object({\n      label: zod.string(),\n      url: zod.string().url(),\n    })\n    .optional(),\n  title: zod.string().optional(),\n  minVersion: zod.string().optional(),\n  maxVersion: zod.string().optional(),\n  minDate: zod.string().optional(),\n  maxDate: zod.string().optional(),\n  commands: zod.array(zod.string()).optional(),\n  surface: zod.string().optional(),\n})\nexport type Notification = zod.infer<typeof NotificationSchema>\n\nconst NotificationsSchema = zod.object({notifications: zod.array(NotificationSchema)})\nexport type Notifications = zod.infer<typeof NotificationsSchema>\n\n/**\n * Shows notifications to the user if they meet the criteria specified in the notifications.json file.\n *\n * @param currentSurfaces - The surfaces present in the current project (usually for app extensions).\n * @param environment - Process environment variables.\n * @returns - A promise that resolves when the notifications have been shown.\n */\nexport async function showNotificationsIfNeeded(\n  currentSurfaces?: string[],\n  environment: NodeJS.ProcessEnv = process.env,\n): Promise<void> {\n  try {\n    if (skipNotifications(environment)) return\n\n    const notifications = await getNotifications()\n    const commandId = getCurrentCommandId()\n    const notificationsToShow = filterNotifications(notifications.notifications, commandId, currentSurfaces)\n    outputDebug(`Notifications to show: ${notificationsToShow.length}`)\n    await renderNotifications(notificationsToShow)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (error: any) {\n    if (error.message === 'abort') throw new AbortSilentError()\n    const errorMessage = `Error retrieving notifications: ${error.message}`\n    outputDebug(errorMessage)\n    // This is very prone to becoming a circular dependency, so we import it dynamically\n    const {sendErrorToBugsnag} = await import('./error-handler.js')\n    await sendErrorToBugsnag(errorMessage, 'unexpected_error')\n  }\n}\n\nfunction skipNotifications(environment: NodeJS.ProcessEnv): boolean {\n  return isTruthy(environment.CI) || isTruthy(environment.SHOPIFY_UNIT_TEST) || jsonOutputEnabled(environment)\n}\n\n/**\n * Renders the first 2 notifications to the user.\n *\n * @param notifications - The notifications to render.\n */\nasync function renderNotifications(notifications: Notification[]) {\n  notifications.slice(0, 2).forEach((notification) => {\n    const content = {\n      headline: notification.title,\n      body: notification.message.replaceAll('\\\\n', '\\n'),\n      link: notification.cta,\n    }\n    switch (notification.type) {\n      case 'info': {\n        renderInfo(content)\n        break\n      }\n      case 'warning': {\n        renderWarning(content)\n        break\n      }\n      case 'error': {\n        renderError(content)\n        throw new Error('abort')\n      }\n    }\n    cacheStore(`notification-${notification.id}`, new Date().getTime().toString())\n  })\n}\n\n/**\n * Get notifications list from cache (refreshed every hour) or fetch it if not present.\n *\n * @returns A Notifications object.\n */\nexport async function getNotifications(): Promise<Notifications> {\n  const cacheKey: NotificationsKey = `notifications-${url()}`\n  const rawNotifications = await cacheRetrieveOrRepopulate(cacheKey, fetchNotifications, CACHE_DURATION_IN_MS)\n  const notifications: object = JSON.parse(rawNotifications)\n  return NotificationsSchema.parse(notifications)\n}\n\n/**\n * Fetch notifications from GitHub.\n */\nasync function fetchNotifications(): Promise<string> {\n  outputDebug(`No cached notifications found. Fetching them...`)\n  const response = await fetch(url(), {signal: AbortSignal.timeout(3 * 1000)})\n  if (response.status !== 200) throw new Error(`Failed to fetch notifications: ${response.statusText}`)\n  return response.text() as unknown as string\n}\n\n/**\n * Filters notifications based on the version of the CLI.\n *\n * @param notifications - The notifications to filter.\n * @param commandId - The command ID to filter by.\n * @param currentSurfaces - The surfaces present in the current project (usually for app extensions).\n * @param today - The current date.\n * @param currentVersion - The current version of the CLI.\n * @returns - The filtered notifications.\n */\nexport function filterNotifications(\n  notifications: Notification[],\n  commandId: string,\n  currentSurfaces?: string[],\n  today: Date = new Date(new Date().setUTCHours(0, 0, 0, 0)),\n  currentVersion: string = CLI_KIT_VERSION,\n): Notification[] {\n  return notifications\n    .filter((notification) => filterByVersion(notification, currentVersion))\n    .filter((notifications) => filterByDate(notifications, today))\n    .filter((notification) => filterByCommand(notification, commandId))\n    .filter((notification) => filterBySurface(notification, commandId, currentSurfaces))\n    .filter((notification) => filterByFrequency(notification))\n}\n\n/**\n * Filters notifications based on the version of the CLI.\n *\n * @param notification - The notification to filter.\n * @param currentVersion - The current version of the CLI.\n */\nfunction filterByVersion(notification: Notification, currentVersion: string) {\n  const minVersion = !notification.minVersion || versionSatisfies(currentVersion, `>=${notification.minVersion}`)\n  const maxVersion = !notification.maxVersion || versionSatisfies(currentVersion, `<=${notification.maxVersion}`)\n  return minVersion && maxVersion\n}\n\n/**\n * Filters notifications based on the date.\n *\n * @param notification - The notification to filter.\n * @param today - The current date.\n */\nfunction filterByDate(notification: Notification, today: Date) {\n  const minDate = !notification.minDate || new Date(notification.minDate) <= today\n  const maxDate = !notification.maxDate || new Date(notification.maxDate) >= today\n  return minDate && maxDate\n}\n\n/**\n * Filters notifications based on the command ID.\n *\n * @param notification - The notification to filter.\n * @param commandId - The command ID to filter by.\n * @returns - A boolean indicating whether the notification should be shown.\n */\nfunction filterByCommand(notification: Notification, commandId: string) {\n  if (commandId === '') return true\n  return !notification.commands || notification.commands.includes(commandId)\n}\n\n/**\n * Filters notifications based on the surface.\n *\n * @param notification - The notification to filter.\n * @param commandId - The command id.\n * @param surfacesFromContext - The surfaces present in the current project (usually for app extensions).\n * @returns - A boolean indicating whether the notification should be shown.\n */\nfunction filterBySurface(notification: Notification, commandId: string, surfacesFromContext?: string[]) {\n  const surfaceFromCommand = commandId.split(':')[0] ?? 'all'\n  const notificationSurface = notification.surface ?? 'all'\n\n  if (surfacesFromContext) return surfacesFromContext.includes(notificationSurface)\n\n  return notificationSurface === surfaceFromCommand || notificationSurface === 'all'\n}\n\n/**\n * Filters notifications based on the frequency.\n *\n * @param notification - The notification to filter.\n * @returns - A boolean indicating whether the notification should be shown.\n */\nfunction filterByFrequency(notification: Notification): boolean {\n  if (!notification.frequency) return true\n  const cacheKey: NotificationKey = `notification-${notification.id}`\n  const lastShown = cacheRetrieve(cacheKey)?.value as unknown as string\n  if (!lastShown) return true\n\n  switch (notification.frequency) {\n    case 'always': {\n      return true\n    }\n    case 'once': {\n      return false\n    }\n    case 'once_a_day': {\n      return new Date().getTime() - Number(lastShown) > 24 * 3600 * 1000\n    }\n    case 'once_a_week': {\n      return new Date().getTime() - Number(lastShown) > 7 * 24 * 3600 * 1000\n    }\n  }\n}\n\n/**\n * Returns a string with the filters from a notification, one by line.\n *\n * @param notification - The notification to get the filters from.\n * @returns A string with human-readable filters from the notification.\n */\nexport function stringifyFilters(notification: Notification): string {\n  const filters = []\n  if (notification.minDate) filters.push(`from ${notification.minDate}`)\n  if (notification.maxDate) filters.push(`to ${notification.maxDate}`)\n  if (notification.minVersion) filters.push(`from v${notification.minVersion}`)\n  if (notification.maxVersion) filters.push(`to v${notification.maxVersion}`)\n  if (notification.frequency === 'once') filters.push('show only once')\n  if (notification.frequency === 'once_a_day') filters.push('show once a day')\n  if (notification.frequency === 'once_a_week') filters.push('show once a week')\n  if (notification.surface) filters.push(`surface = ${notification.surface}`)\n  if (notification.commands) filters.push(`commands = ${notification.commands.join(', ')}`)\n  return filters.join('\\n')\n}\n", "export interface GlobalContext {\n  currentCommandId: string\n}\n\nlet _globalContext: GlobalContext | undefined\n\n/**\n * Get the global context.\n *\n * @returns Global context.\n */\nfunction getGlobalContext(): GlobalContext {\n  if (!_globalContext) {\n    _globalContext = {currentCommandId: ''}\n  }\n  return _globalContext\n}\n\n/**\n * Get the current command ID.\n *\n * @returns Current command ID.\n */\nexport function getCurrentCommandId(): string {\n  return getGlobalContext().currentCommandId\n}\n\n/**\n * Set the current command ID.\n *\n * @param commandId - Command ID.\n */\nexport function setCurrentCommandId(commandId: string): void {\n  getGlobalContext().currentCommandId = commandId\n}\n"],
  "mappings": "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",
  "names": ["notifications"]
}
