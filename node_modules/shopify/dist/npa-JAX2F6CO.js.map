{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/lru-cache@10.2.2/node_modules/lru-cache/src/index.ts", "../../../node_modules/.pnpm/hosted-git-info@7.0.2/node_modules/hosted-git-info/lib/hosts.js", "../../../node_modules/.pnpm/hosted-git-info@7.0.2/node_modules/hosted-git-info/lib/parse-url.js", "../../../node_modules/.pnpm/hosted-git-info@7.0.2/node_modules/hosted-git-info/lib/from-url.js", "../../../node_modules/.pnpm/hosted-git-info@7.0.2/node_modules/hosted-git-info/lib/index.js", "../../../node_modules/.pnpm/proc-log@4.2.0/node_modules/proc-log/lib/index.js", "../../../node_modules/.pnpm/npm-package-arg@11.0.2/node_modules/npm-package-arg/lib/npa.js"],
  "sourcesContent": ["/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   */\n  export type DisposeReason = 'evict' | 'set' | 'delete'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Status object that may be passed to {@link LRUCache#fetch},\n   * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no fetchMethod, so {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed\n     * by default, and MAY live in the cache long after they have expired.\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * Must be an integer number of ms. If set to 0, this indicates \"no TTL\"\n     *\n     * @default 0\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     * Note that this may significantly degrade performance,\n     * especially if the cache is storing a large number of items.\n     * It is almost always best to just leave the stale items in\n     * the cache, and let them fall out as new items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * @default false\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#get}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#has}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the cache.\n     * This can be handy if you want to close file descriptors or do other\n     * cleanup tasks when items are no longer accessible. Called with `key,\n     * value`.  It's called before actually removing the item from the\n     * internal cache, so it is *NOT* safe to re-add them.\n     *\n     * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after\n     * they have been full removed, when it is safe to add them back to the\n     * cache.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when\n     * setting a new value for an existing key (ie, when updating a value\n     * rather than inserting a new value).  Note that the TTL value is\n     * _always_ set (if provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * If you wish to track item size, you must provide a maxSize\n     * note that we still will only keep up to max *actual items*,\n     * if max is set, so size tracking may cause fewer than max items\n     * to be stored.  At the extreme, a single item of maxSize size\n     * will cause everything else in the cache to be dropped when it\n     * is added.  Use with caution!\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod}, then it will not be stored in the\n     * cache.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the\n     * {@link LRUCache#fetch} fails, not any other times.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`\n     * event, whether user-triggered, or due to internal cache behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls are not\n     * immediately resolved or rejected when they are aborted, and instead\n     * take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K,V> {\n  // properties coming in from the options of these, only max and maxSize\n  // really *need* to be protected. The rest can be modified, as they just\n  // set defaults for various methods.\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.delete(this.#keyList[index] as K)\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string description of an object.\n   * Called by the built-in method Object.prototype.toString.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.delete(this.#keyList[i] as K)\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a\n   * single key. Always returns stale values, if their info is found in the\n   * cache, so be sure to check for expired TTLs if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.delete(k)\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   */\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.clear()\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, 'delete')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, 'delete'])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, 'delete')\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, 'delete'])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "/* eslint-disable max-len */\n\n'use strict'\n\nconst maybeJoin = (...args) => args.every(arg => arg) ? args.join('') : ''\nconst maybeEncode = (arg) => arg ? encodeURIComponent(arg) : ''\nconst formatHashFragment = (f) => f.toLowerCase().replace(/^\\W+|\\/|\\W+$/g, '').replace(/\\W+/g, '-')\n\nconst defaults = {\n  sshtemplate: ({ domain, user, project, committish }) =>\n    `git@${domain}:${user}/${project}.git${maybeJoin('#', committish)}`,\n  sshurltemplate: ({ domain, user, project, committish }) =>\n    `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  edittemplate: ({ domain, user, project, committish, editpath, path }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path)}`,\n  browsetemplate: ({ domain, user, project, committish, treepath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}`,\n  browsetreetemplate: ({ domain, user, project, committish, treepath, path, fragment, hashformat }) =>\n    `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,\n  browseblobtemplate: ({ domain, user, project, committish, blobpath, path, fragment, hashformat }) =>\n    `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,\n  docstemplate: ({ domain, user, project, treepath, committish }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}#readme`,\n  httpstemplate: ({ auth, domain, user, project, committish }) =>\n    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  filetemplate: ({ domain, user, project, committish, path }) =>\n    `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || 'HEAD')}/${path}`,\n  shortcuttemplate: ({ type, user, project, committish }) =>\n    `${type}:${user}/${project}${maybeJoin('#', committish)}`,\n  pathtemplate: ({ user, project, committish }) =>\n    `${user}/${project}${maybeJoin('#', committish)}`,\n  bugstemplate: ({ domain, user, project }) =>\n    `https://${domain}/${user}/${project}/issues`,\n  hashformat: formatHashFragment,\n}\n\nconst hosts = {}\nhosts.github = {\n  // First two are insecure and generally shouldn't be used any more, but\n  // they are still supported.\n  protocols: ['git:', 'http:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'github.com',\n  treepath: 'tree',\n  blobpath: 'blob',\n  editpath: 'edit',\n  filetemplate: ({ auth, user, project, committish, path }) =>\n    `https://${maybeJoin(auth, '@')}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || 'HEAD')}/${path}`,\n  gittemplate: ({ auth, domain, user, project, committish }) =>\n    `git://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    let [, user, project, type, committish] = url.pathname.split('/', 5)\n    if (type && type !== 'tree') {\n      return\n    }\n\n    if (!type) {\n      committish = url.hash.slice(1)\n    }\n\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish }\n  },\n}\n\nhosts.bitbucket = {\n  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'bitbucket.org',\n  treepath: 'src',\n  blobpath: 'src',\n  editpath: '?mode=edit',\n  edittemplate: ({ domain, user, project, committish, treepath, path, editpath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/get/${maybeEncode(committish || 'HEAD')}.tar.gz`,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4)\n    if (['get'].includes(aux)) {\n      return\n    }\n\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n}\n\nhosts.gitlab = {\n  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'gitlab.com',\n  treepath: 'tree',\n  blobpath: 'tree',\n  editpath: '-/edit',\n  httpstemplate: ({ auth, domain, user, project, committish }) =>\n    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    const path = url.pathname.slice(1)\n    if (path.includes('/-/') || path.includes('/archive.tar.gz')) {\n      return\n    }\n\n    const segments = path.split('/')\n    let project = segments.pop()\n    if (project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    const user = segments.join('/')\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n}\n\nhosts.gist = {\n  protocols: ['git:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'gist.github.com',\n  editpath: 'edit',\n  sshtemplate: ({ domain, project, committish }) =>\n    `git@${domain}:${project}.git${maybeJoin('#', committish)}`,\n  sshurltemplate: ({ domain, project, committish }) =>\n    `git+ssh://git@${domain}/${project}.git${maybeJoin('#', committish)}`,\n  edittemplate: ({ domain, user, project, committish, editpath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', maybeEncode(committish))}/${editpath}`,\n  browsetemplate: ({ domain, project, committish }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,\n  browsetreetemplate: ({ domain, project, committish, path, hashformat }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,\n  browseblobtemplate: ({ domain, project, committish, path, hashformat }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,\n  docstemplate: ({ domain, project, committish }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,\n  httpstemplate: ({ domain, project, committish }) =>\n    `git+https://${domain}/${project}.git${maybeJoin('#', committish)}`,\n  filetemplate: ({ user, project, committish, path }) =>\n    `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin('/', maybeEncode(committish))}/${path}`,\n  shortcuttemplate: ({ type, project, committish }) =>\n    `${type}:${project}${maybeJoin('#', committish)}`,\n  pathtemplate: ({ project, committish }) =>\n    `${project}${maybeJoin('#', committish)}`,\n  bugstemplate: ({ domain, project }) =>\n    `https://${domain}/${project}`,\n  gittemplate: ({ domain, project, committish }) =>\n    `git://${domain}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ project, committish }) =>\n    `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4)\n    if (aux === 'raw') {\n      return\n    }\n\n    if (!project) {\n      if (!user) {\n        return\n      }\n\n      project = user\n      user = null\n    }\n\n    if (project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n  hashformat: function (fragment) {\n    return fragment && 'file-' + formatHashFragment(fragment)\n  },\n}\n\nhosts.sourcehut = {\n  protocols: ['git+ssh:', 'https:'],\n  domain: 'git.sr.ht',\n  treepath: 'tree',\n  blobpath: 'tree',\n  filetemplate: ({ domain, user, project, committish, path }) =>\n    `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || 'HEAD'}/${path}`,\n  httpstemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || 'HEAD'}.tar.gz`,\n  bugstemplate: () => null,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4)\n\n    // tarball url\n    if (['archive'].includes(aux)) {\n      return\n    }\n\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n}\n\nfor (const [name, host] of Object.entries(hosts)) {\n  hosts[name] = Object.assign({}, defaults, host)\n}\n\nmodule.exports = hosts\n", "const url = require('url')\n\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar)\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)\n}\n\nconst safeUrl = (u) => {\n  try {\n    return new url.URL(u)\n  } catch {\n    // this fn should never throw\n  }\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  // ignore @ that come after the first hash since the denotes the start\n  // of a committish which can contain @ characters\n  const firstAt = lastIndexOfBefore(giturl, '@', '#')\n  // ignore colons that come after the hash since that could include colons such as:\n  // git@github.com:user/package-2#semver:^1.0.0\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#')\n\n  if (lastColonBeforeHash > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1)\n  }\n\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    giturl = `git+ssh://${giturl}`\n  }\n\n  return giturl\n}\n\nmodule.exports = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))\n}\n", "'use strict'\n\nconst parseUrl = require('./parse-url')\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = (arg) => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#')\n  const firstSlash = arg.indexOf('/')\n  const secondSlash = arg.indexOf('/', firstSlash + 1)\n  const firstColon = arg.indexOf(':')\n  const firstSpace = /\\s/.exec(arg)\n  const firstAt = arg.indexOf('@')\n\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash)\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash)\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)\n  const hasSlash = firstSlash > 0\n  // if a # is found, what we really want to know is that the character\n  // immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')\n  const doesNotStartWithDot = !arg.startsWith('.')\n\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash &&\n    doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash &&\n    secondSlashOnlyAfterHash\n}\n\nmodule.exports = (giturl, opts, { gitHosts, protocols }) => {\n  if (!giturl) {\n    return\n  }\n\n  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl\n  const parsed = parseUrl(correctedUrl, protocols)\n  if (!parsed) {\n    return\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.')\n    ? parsed.hostname.slice(4)\n    : parsed.hostname]\n  const gitHostName = gitHostShortcut || gitHostDomain\n  if (!gitHostName) {\n    return\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]\n  let auth = null\n  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`\n  }\n\n  let committish = null\n  let user = null\n  let project = null\n  let defaultRepresentation = null\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname\n      const firstAt = pathname.indexOf('@')\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1)\n      }\n\n      const lastSlash = pathname.lastIndexOf('/')\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash))\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1))\n      } else {\n        project = decodeURIComponent(pathname)\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4)\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1))\n      }\n\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n\n      const segments = gitHostInfo.extract(parsed)\n      if (!segments) {\n        return\n      }\n\n      user = segments.user && decodeURIComponent(segments.user)\n      project = decodeURIComponent(segments.project)\n      committish = decodeURIComponent(segments.committish)\n      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1)\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n\n  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts]\n}\n", "'use strict'\n\nconst { LRUCache } = require('lru-cache')\nconst hosts = require('./hosts.js')\nconst fromUrl = require('./from-url.js')\nconst parseUrl = require('./parse-url.js')\n\nconst cache = new LRUCache({ max: 1000 })\n\nclass GitHost {\n  constructor (type, user, auth, project, committish, defaultRepresentation, opts = {}) {\n    Object.assign(this, GitHost.#gitHosts[type], {\n      type,\n      user,\n      auth,\n      project,\n      committish,\n      default: defaultRepresentation,\n      opts,\n    })\n  }\n\n  static #gitHosts = { byShortcut: {}, byDomain: {} }\n  static #protocols = {\n    'git+ssh:': { name: 'sshurl' },\n    'ssh:': { name: 'sshurl' },\n    'git+https:': { name: 'https', auth: true },\n    'git:': { auth: true },\n    'http:': { auth: true },\n    'https:': { auth: true },\n    'git+http:': { auth: true },\n  }\n\n  static addHost (name, host) {\n    GitHost.#gitHosts[name] = host\n    GitHost.#gitHosts.byDomain[host.domain] = name\n    GitHost.#gitHosts.byShortcut[`${name}:`] = name\n    GitHost.#protocols[`${name}:`] = { name }\n  }\n\n  static fromUrl (giturl, opts) {\n    if (typeof giturl !== 'string') {\n      return\n    }\n\n    const key = giturl + JSON.stringify(opts || {})\n\n    if (!cache.has(key)) {\n      const hostArgs = fromUrl(giturl, opts, {\n        gitHosts: GitHost.#gitHosts,\n        protocols: GitHost.#protocols,\n      })\n      cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined)\n    }\n\n    return cache.get(key)\n  }\n\n  static parseUrl (url) {\n    return parseUrl(url)\n  }\n\n  #fill (template, opts) {\n    if (typeof template !== 'function') {\n      return null\n    }\n\n    const options = { ...this, ...this.opts, ...opts }\n\n    // the path should always be set so we don't end up with 'undefined' in urls\n    if (!options.path) {\n      options.path = ''\n    }\n\n    // template functions will insert the leading slash themselves\n    if (options.path.startsWith('/')) {\n      options.path = options.path.slice(1)\n    }\n\n    if (options.noCommittish) {\n      options.committish = null\n    }\n\n    const result = template(options)\n    return options.noGitPlus && result.startsWith('git+') ? result.slice(4) : result\n  }\n\n  hash () {\n    return this.committish ? `#${this.committish}` : ''\n  }\n\n  ssh (opts) {\n    return this.#fill(this.sshtemplate, opts)\n  }\n\n  sshurl (opts) {\n    return this.#fill(this.sshurltemplate, opts)\n  }\n\n  browse (path, ...args) {\n    // not a string, treat path as opts\n    if (typeof path !== 'string') {\n      return this.#fill(this.browsetemplate, path)\n    }\n\n    if (typeof args[0] !== 'string') {\n      return this.#fill(this.browsetreetemplate, { ...args[0], path })\n    }\n\n    return this.#fill(this.browsetreetemplate, { ...args[1], fragment: args[0], path })\n  }\n\n  // If the path is known to be a file, then browseFile should be used. For some hosts\n  // the url is the same as browse, but for others like GitHub a file can use both `/tree/`\n  // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`\n  // path will redirect to a specific commit. Using the `/blob/` path avoids this and\n  // does not redirect to a different commit.\n  browseFile (path, ...args) {\n    if (typeof args[0] !== 'string') {\n      return this.#fill(this.browseblobtemplate, { ...args[0], path })\n    }\n\n    return this.#fill(this.browseblobtemplate, { ...args[1], fragment: args[0], path })\n  }\n\n  docs (opts) {\n    return this.#fill(this.docstemplate, opts)\n  }\n\n  bugs (opts) {\n    return this.#fill(this.bugstemplate, opts)\n  }\n\n  https (opts) {\n    return this.#fill(this.httpstemplate, opts)\n  }\n\n  git (opts) {\n    return this.#fill(this.gittemplate, opts)\n  }\n\n  shortcut (opts) {\n    return this.#fill(this.shortcuttemplate, opts)\n  }\n\n  path (opts) {\n    return this.#fill(this.pathtemplate, opts)\n  }\n\n  tarball (opts) {\n    return this.#fill(this.tarballtemplate, { ...opts, noCommittish: false })\n  }\n\n  file (path, opts) {\n    return this.#fill(this.filetemplate, { ...opts, path })\n  }\n\n  edit (path, opts) {\n    return this.#fill(this.edittemplate, { ...opts, path })\n  }\n\n  getDefaultRepresentation () {\n    return this.default\n  }\n\n  toString (opts) {\n    if (this.default && typeof this[this.default] === 'function') {\n      return this[this.default](opts)\n    }\n\n    return this.sshurl(opts)\n  }\n}\n\nfor (const [name, host] of Object.entries(hosts)) {\n  GitHost.addHost(name, host)\n}\n\nmodule.exports = GitHost\n", "const META = Symbol('proc-log.meta')\nmodule.exports = {\n  META: META,\n  output: {\n    LEVELS: [\n      'standard',\n      'error',\n      'buffer',\n      'flush',\n    ],\n    KEYS: {\n      standard: 'standard',\n      error: 'error',\n      buffer: 'buffer',\n      flush: 'flush',\n    },\n    standard: function (...args) {\n      return process.emit('output', 'standard', ...args)\n    },\n    error: function (...args) {\n      return process.emit('output', 'error', ...args)\n    },\n    buffer: function (...args) {\n      return process.emit('output', 'buffer', ...args)\n    },\n    flush: function (...args) {\n      return process.emit('output', 'flush', ...args)\n    },\n  },\n  log: {\n    LEVELS: [\n      'notice',\n      'error',\n      'warn',\n      'info',\n      'verbose',\n      'http',\n      'silly',\n      'timing',\n      'pause',\n      'resume',\n    ],\n    KEYS: {\n      notice: 'notice',\n      error: 'error',\n      warn: 'warn',\n      info: 'info',\n      verbose: 'verbose',\n      http: 'http',\n      silly: 'silly',\n      timing: 'timing',\n      pause: 'pause',\n      resume: 'resume',\n    },\n    error: function (...args) {\n      return process.emit('log', 'error', ...args)\n    },\n    notice: function (...args) {\n      return process.emit('log', 'notice', ...args)\n    },\n    warn: function (...args) {\n      return process.emit('log', 'warn', ...args)\n    },\n    info: function (...args) {\n      return process.emit('log', 'info', ...args)\n    },\n    verbose: function (...args) {\n      return process.emit('log', 'verbose', ...args)\n    },\n    http: function (...args) {\n      return process.emit('log', 'http', ...args)\n    },\n    silly: function (...args) {\n      return process.emit('log', 'silly', ...args)\n    },\n    timing: function (...args) {\n      return process.emit('log', 'timing', ...args)\n    },\n    pause: function () {\n      return process.emit('log', 'pause')\n    },\n    resume: function () {\n      return process.emit('log', 'resume')\n    },\n  },\n  time: {\n    LEVELS: [\n      'start',\n      'end',\n    ],\n    KEYS: {\n      start: 'start',\n      end: 'end',\n    },\n    start: function (name, fn) {\n      process.emit('time', 'start', name)\n      function end () {\n        return process.emit('time', 'end', name)\n      }\n      if (typeof fn === 'function') {\n        const res = fn()\n        if (res && res.finally) {\n          return res.finally(end)\n        }\n        end()\n        return res\n      }\n      return end\n    },\n    end: function (name) {\n      return process.emit('time', 'end', name)\n    },\n  },\n  input: {\n    LEVELS: [\n      'start',\n      'end',\n      'read',\n    ],\n    KEYS: {\n      start: 'start',\n      end: 'end',\n      read: 'read',\n    },\n    start: function (fn) {\n      process.emit('input', 'start')\n      function end () {\n        return process.emit('input', 'end')\n      }\n      if (typeof fn === 'function') {\n        const res = fn()\n        if (res && res.finally) {\n          return res.finally(end)\n        }\n        end()\n        return res\n      }\n      return end\n    },\n    end: function () {\n      return process.emit('input', 'end')\n    },\n    read: function (...args) {\n      let resolve, reject\n      const promise = new Promise((_resolve, _reject) => {\n        resolve = _resolve\n        reject = _reject\n      })\n      process.emit('input', 'read', resolve, reject, ...args)\n      return promise\n    },\n  },\n}\n", "'use strict'\nmodule.exports = npa\nmodule.exports.resolve = resolve\nmodule.exports.toPurl = toPurl\nmodule.exports.Result = Result\n\nconst { URL } = require('url')\nconst HostedGit = require('hosted-git-info')\nconst semver = require('semver')\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path')\nconst validatePackageName = require('validate-npm-package-name')\nconst { homedir } = require('os')\nconst { log } = require('proc-log')\n\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/\nconst isURL = /^(?:git[+])?[a-z]+:/i\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i\n\nfunction npa (arg, where) {\n  let name\n  let spec\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)\n    } else {\n      return npa(arg.raw, where || arg.where)\n    }\n  }\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@')\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg\n  if (isURL.test(arg)) {\n    spec = arg\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg\n  } else if (nameEndsAt > 0) {\n    name = namePart\n    spec = arg.slice(nameEndsAt + 1) || '*'\n  } else {\n    const valid = validatePackageName(arg)\n    if (valid.validForOldPackages) {\n      name = arg\n      spec = '*'\n    } else {\n      spec = arg\n    }\n  }\n  return resolve(name, spec, where, arg)\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/\n\nfunction resolve (name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null,\n  })\n\n  if (name) {\n    res.setName(name)\n  }\n\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where)\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where)\n  }\n\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true,\n  })\n  if (hosted) {\n    return fromHostedGit(res, hosted)\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res)\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where)\n  } else {\n    return fromRegistry(res)\n  }\n}\n\nconst defaultRegistry = 'https://registry.npmjs.org'\n\nfunction toPurl (arg, reg = defaultRegistry) {\n  const res = npa(arg)\n\n  if (res.type !== 'version') {\n    throw invalidPurlType(res.type, res.raw)\n  }\n\n  // URI-encode leading @ of scoped packages\n  let purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec\n  if (reg !== defaultRegistry) {\n    purl += '?repository_url=' + reg\n  }\n\n  return purl\n}\n\nfunction invalidPackageName (name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`)\n  err.code = 'EINVALIDPACKAGENAME'\n  return err\n}\n\nfunction invalidTagName (name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`)\n  err.code = 'EINVALIDTAGNAME'\n  return err\n}\n\nfunction invalidPurlType (type, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid type \"${type}\" of package \"${raw}\": Purl can only be generated for \"version\" types.`)\n  err.code = 'EINVALIDPURLTYPE'\n  return err\n}\n\nfunction Result (opts) {\n  this.type = opts.type\n  this.registry = opts.registry\n  this.where = opts.where\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec\n  } else {\n    this.raw = opts.raw\n  }\n\n  this.name = undefined\n  this.escapedName = undefined\n  this.scope = undefined\n  this.rawSpec = opts.rawSpec || ''\n  this.saveSpec = opts.saveSpec\n  this.fetchSpec = opts.fetchSpec\n  if (opts.name) {\n    this.setName(opts.name)\n  }\n  this.gitRange = opts.gitRange\n  this.gitCommittish = opts.gitCommittish\n  this.gitSubdir = opts.gitSubdir\n  this.hosted = opts.hosted\n}\n\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name)\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid, this.raw)\n  }\n\n  this.name = name\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined\n  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n  this.escapedName = name.replace('/', '%2f')\n  return this\n}\n\nResult.prototype.toString = function () {\n  const full = []\n  if (this.name != null && this.name !== '') {\n    full.push(this.name)\n  }\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec\n  if (spec != null && spec !== '') {\n    full.push(spec)\n  }\n  return full.length ? full.join('@') : this.raw\n}\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this)\n  delete result.hosted\n  return result\n}\n\n// sets res.gitCommittish, res.gitRange, and res.gitSubdir\nfunction setGitAttrs (res, committish) {\n  if (!committish) {\n    res.gitCommittish = null\n    return\n  }\n\n  // for each :: separated item:\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish')\n      }\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish')\n      }\n      res.gitCommittish = part\n      continue\n    }\n    // split on name:value\n    const [name, value] = part.split(':')\n    // if name is semver do semver lookup of ref or tag\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range')\n      }\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range')\n      }\n      res.gitRange = decodeURIComponent(value)\n      continue\n    }\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path')\n      }\n      res.gitSubdir = `/${value}`\n      continue\n    }\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`)\n  }\n}\n\nfunction fromFile (res, where) {\n  if (!where) {\n    where = process.cwd()\n  }\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory'\n  res.where = where\n\n  // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/bar/foo\n\n  let specUrl\n  let resolvedUrl\n  const prefix = (!/^file:/.test(res.rawSpec) ? 'file:' : '')\n  const rawWithPrefix = prefix + res.rawSpec\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '')\n  try {\n    resolvedUrl = new URL(rawWithPrefix, `file://${path.resolve(where)}/`)\n    specUrl = new URL(rawWithPrefix)\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8089')\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError,\n    })\n  }\n\n  // XXX backwards compatibility lack of compliance with RFC 8089\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///')\n    resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`)\n    specUrl = new URL(rawSpec)\n    rawNoPrefix = rawSpec.replace(/^file:/, '')\n  }\n  // turn file:/../foo into file:../foo\n  // for 1, 2 or 3 leading slashes since we attempted\n  // in the previous step to make it a file protocol url with a leading slash\n  if (/^\\/{1,3}\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n    const rawSpec = res.rawSpec.replace(/^file:\\/{1,3}/, 'file:')\n    resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`)\n    specUrl = new URL(rawSpec)\n    rawNoPrefix = rawSpec.replace(/^file:/, '')\n  }\n  // XXX end RFC 8089 violation backwards compatibility section\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname)\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname)\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`\n    resolvedPath = path.resolve(homedir(), specPath.substr(3))\n  } else if (!path.isAbsolute(rawNoPrefix)) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`\n  }\n\n  res.fetchSpec = path.resolve(where, resolvedPath)\n  return res\n}\n\nfunction fromHostedGit (res, hosted) {\n  res.type = 'git'\n  res.hosted = hosted\n  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false })\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString()\n  setGitAttrs(res, hosted.committish)\n  return res\n}\n\nfunction unsupportedURLType (protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`)\n  err.code = 'EUNSUPPORTEDPROTOCOL'\n  return err\n}\n\nfunction fromURL (res) {\n  let rawSpec = res.rawSpec\n  res.saveSpec = rawSpec\n  if (rawSpec.startsWith('git+ssh:')) {\n    // git ssh specifiers are overloaded to also use scp-style git\n    // specifiers, so we have to parse those out and treat them special.\n    // They are NOT true URIs, so we can't hand them to URL.\n\n    // This regex looks for things that look like:\n    // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n    // ...and various combinations. The username in the beginning is *required*.\n    const matched = rawSpec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i)\n    if (matched && !matched[1].match(/:[0-9]+\\/?.*$/i)) {\n      res.type = 'git'\n      setGitAttrs(res, matched[2])\n      res.fetchSpec = matched[1]\n      return res\n    }\n  } else if (rawSpec.startsWith('git+file://')) {\n    // URL can't handle windows paths\n    rawSpec = rawSpec.replace(/\\\\/g, '/')\n  }\n  const parsedUrl = new URL(rawSpec)\n  // check the protocol, and then see if it's git or not\n  switch (parsedUrl.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:':\n      res.type = 'git'\n      setGitAttrs(res, parsedUrl.hash.slice(1))\n      if (parsedUrl.protocol === 'git+file:' && /^git\\+file:\\/\\/[a-z]:/i.test(rawSpec)) {\n        // URL can't handle drive letters on windows file paths, the host can't contain a :\n        res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`\n      } else {\n        parsedUrl.hash = ''\n        res.fetchSpec = parsedUrl.toString()\n      }\n      if (res.fetchSpec.startsWith('git+')) {\n        res.fetchSpec = res.fetchSpec.slice(4)\n      }\n      break\n    case 'http:':\n    case 'https:':\n      res.type = 'remote'\n      res.fetchSpec = res.saveSpec\n      break\n\n    default:\n      throw unsupportedURLType(parsedUrl.protocol, rawSpec)\n  }\n\n  return res\n}\n\nfunction fromAlias (res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where)\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported')\n  }\n\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps')\n  }\n\n  res.subSpec = subSpec\n  res.registry = true\n  res.type = 'alias'\n  res.saveSpec = null\n  res.fetchSpec = null\n  return res\n}\n\nfunction fromRegistry (res) {\n  res.registry = true\n  const spec = res.rawSpec.trim()\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null\n  res.fetchSpec = spec\n  const version = semver.valid(spec, true)\n  const range = semver.validRange(spec, true)\n  if (version) {\n    res.type = 'version'\n  } else if (range) {\n    res.type = 'range'\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw)\n    }\n    res.type = 'tag'\n  }\n  return res\n}\n"],
  "mappings": "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",
  "names": ["v", "bf", "require_lib", "require_lib"]
}
