{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/slash@3.0.0/node_modules/slash/index.js", "../../../node_modules/.pnpm/array-union@2.1.0/node_modules/array-union/index.js", "../../../node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js", "../../../node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js", "../../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js", "../../../node_modules/.pnpm/globby@11.1.0/node_modules/globby/gitignore.js", "../../../node_modules/.pnpm/globby@11.1.0/node_modules/globby/stream-utils.js", "../../../node_modules/.pnpm/globby@11.1.0/node_modules/globby/index.js", "../../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js"],
  "sourcesContent": ["'use strict';\nmodule.exports = path => {\n\tconst isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(path);\n\tconst hasNonAscii = /[^\\u0000-\\u0080]+/.test(path); // eslint-disable-line no-control-regex\n\n\tif (isExtendedLengthPath || hasNonAscii) {\n\t\treturn path;\n\t}\n\n\treturn path.replace(/\\\\/g, '/');\n};\n", "'use strict';\n\nmodule.exports = (...arguments_) => {\n\treturn [...new Set([].concat(...arguments_))];\n};\n", "'use strict';\nconst {promisify} = require('util');\nconst fs = require('fs');\n\nasync function isType(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\tconst stats = await promisify(fs[fsStatType])(filePath);\n\t\treturn stats[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nfunction isTypeSync(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\treturn fs[fsStatType](filePath)[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexports.isFile = isType.bind(null, 'stat', 'isFile');\nexports.isDirectory = isType.bind(null, 'stat', 'isDirectory');\nexports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');\nexports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');\nexports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');\nexports.isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');\n", "'use strict';\nconst path = require('path');\nconst pathType = require('path-type');\n\nconst getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];\n\nconst getPath = (filepath, cwd) => {\n\tconst pth = filepath[0] === '!' ? filepath.slice(1) : filepath;\n\treturn path.isAbsolute(pth) ? pth : path.join(cwd, pth);\n};\n\nconst addExtensions = (file, extensions) => {\n\tif (path.extname(file)) {\n\t\treturn `**/${file}`;\n\t}\n\n\treturn `**/${file}.${getExtensions(extensions)}`;\n};\n\nconst getGlob = (directory, options) => {\n\tif (options.files && !Array.isArray(options.files)) {\n\t\tthrow new TypeError(`Expected \\`files\\` to be of type \\`Array\\` but received type \\`${typeof options.files}\\``);\n\t}\n\n\tif (options.extensions && !Array.isArray(options.extensions)) {\n\t\tthrow new TypeError(`Expected \\`extensions\\` to be of type \\`Array\\` but received type \\`${typeof options.extensions}\\``);\n\t}\n\n\tif (options.files && options.extensions) {\n\t\treturn options.files.map(x => path.posix.join(directory, addExtensions(x, options.extensions)));\n\t}\n\n\tif (options.files) {\n\t\treturn options.files.map(x => path.posix.join(directory, `**/${x}`));\n\t}\n\n\tif (options.extensions) {\n\t\treturn [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];\n\t}\n\n\treturn [path.posix.join(directory, '**')];\n};\n\nmodule.exports = async (input, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\t...options\n\t};\n\n\tif (typeof options.cwd !== 'string') {\n\t\tthrow new TypeError(`Expected \\`cwd\\` to be of type \\`string\\` but received type \\`${typeof options.cwd}\\``);\n\t}\n\n\tconst globs = await Promise.all([].concat(input).map(async x => {\n\t\tconst isDirectory = await pathType.isDirectory(getPath(x, options.cwd));\n\t\treturn isDirectory ? getGlob(x, options) : x;\n\t}));\n\n\treturn [].concat.apply([], globs); // eslint-disable-line prefer-spread\n};\n\nmodule.exports.sync = (input, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\t...options\n\t};\n\n\tif (typeof options.cwd !== 'string') {\n\t\tthrow new TypeError(`Expected \\`cwd\\` to be of type \\`string\\` but received type \\`${typeof options.cwd}\\``);\n\t}\n\n\tconst globs = [].concat(input).map(x => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);\n\n\treturn [].concat.apply([], globs); // eslint-disable-line prefer-spread\n};\n", "// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/\n\nconst SLASH = '/'\n\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = 'node-ignore'\n/* istanbul ignore else */\nif (typeof Symbol !== 'undefined') {\n  TMP_KEY_IGNORE = Symbol.for('node-ignore')\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\nconst RETURN_FALSE = () => false\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  [\n    // remove BOM\n    // TODO:\n    // Other similar zero-width characters?\n    /^\\uFEFF/,\n    () => EMPTY\n  ],\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? SPACE\n      : EMPTY\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => SPACE\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // normal intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule,\n    //    coz trailing single wildcard will be handed by [trailing wildcard]\n    /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1, p2) => {\n      // 1.\n      // > An asterisk \"*\" matches anything except a slash.\n      // 2.\n      // > Other consecutive asterisks are considered regular asterisks\n      // > and will match according to the previous rules.\n      const unescaped = p2.replace(/\\\\\\*/g, '[^\\\\/]*')\n      return p1 + unescaped\n    }\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (_, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match EMPTY\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null)\n\n// @param {pattern}\nconst makeRegex = (pattern, ignoreCase) => {\n  let source = regexCache[pattern]\n\n  if (!source) {\n    source = REPLACERS.reduce(\n      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n      pattern\n    )\n    regexCache[pattern] = source\n  }\n\n  return ignoreCase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n  && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)\n\nclass IgnoreRule {\n  constructor (\n    origin,\n    pattern,\n    negative,\n    regex\n  ) {\n    this.origin = origin\n    this.pattern = pattern\n    this.negative = negative\n    this.regex = regex\n  }\n}\n\nconst createRule = (pattern, ignoreCase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regex = makeRegex(pattern, ignoreCase)\n\n  return new IgnoreRule(\n    origin,\n    pattern,\n    negative,\n    regex\n  )\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\ncheckPath.convert = p => p\n\nclass Ignore {\n  constructor ({\n    ignorecase = true,\n    ignoreCase = ignorecase,\n    allowRelativePaths = false\n  } = {}) {\n    define(this, KEY_IGNORE, true)\n\n    this._rules = []\n    this._ignoreCase = ignoreCase\n    this._allowRelativePaths = allowRelativePaths\n    this._initCache()\n  }\n\n  _initCache () {\n    this._ignoreCache = Object.create(null)\n    this._testCache = Object.create(null)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignoreCase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n\n  // @returns {TestResult} true if a file is ignored\n  _testOne (path, checkUnignored) {\n    let ignored = false\n    let unignored = false\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule.regex.test(path)\n\n      if (matched) {\n        ignored = !negative\n        unignored = negative\n      }\n    })\n\n    return {\n      ignored,\n      unignored\n    }\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(\n      path,\n      originalPath,\n      this._allowRelativePaths\n        ? RETURN_FALSE\n        : throwError\n    )\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  _t (path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._testOne(path, checkUnignored)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)\n\nfactory.isPathValid = isPathValid\n\n// Fixes typescript\nfactory.default = factory\n\nmodule.exports = factory\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n", "'use strict';\nconst {promisify} = require('util');\nconst fs = require('fs');\nconst path = require('path');\nconst fastGlob = require('fast-glob');\nconst gitIgnore = require('ignore');\nconst slash = require('slash');\n\nconst DEFAULT_IGNORE = [\n\t'**/node_modules/**',\n\t'**/flow-typed/**',\n\t'**/coverage/**',\n\t'**/.git'\n];\n\nconst readFileP = promisify(fs.readFile);\n\nconst mapGitIgnorePatternTo = base => ignore => {\n\tif (ignore.startsWith('!')) {\n\t\treturn '!' + path.posix.join(base, ignore.slice(1));\n\t}\n\n\treturn path.posix.join(base, ignore);\n};\n\nconst parseGitIgnore = (content, options) => {\n\tconst base = slash(path.relative(options.cwd, path.dirname(options.fileName)));\n\n\treturn content\n\t\t.split(/\\r?\\n/)\n\t\t.filter(Boolean)\n\t\t.filter(line => !line.startsWith('#'))\n\t\t.map(mapGitIgnorePatternTo(base));\n};\n\nconst reduceIgnore = files => {\n\tconst ignores = gitIgnore();\n\tfor (const file of files) {\n\t\tignores.add(parseGitIgnore(file.content, {\n\t\t\tcwd: file.cwd,\n\t\t\tfileName: file.filePath\n\t\t}));\n\t}\n\n\treturn ignores;\n};\n\nconst ensureAbsolutePathForCwd = (cwd, p) => {\n\tcwd = slash(cwd);\n\tif (path.isAbsolute(p)) {\n\t\tif (slash(p).startsWith(cwd)) {\n\t\t\treturn p;\n\t\t}\n\n\t\tthrow new Error(`Path ${p} is not in cwd ${cwd}`);\n\t}\n\n\treturn path.join(cwd, p);\n};\n\nconst getIsIgnoredPredecate = (ignores, cwd) => {\n\treturn p => ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));\n};\n\nconst getFile = async (file, cwd) => {\n\tconst filePath = path.join(cwd, file);\n\tconst content = await readFileP(filePath, 'utf8');\n\n\treturn {\n\t\tcwd,\n\t\tfilePath,\n\t\tcontent\n\t};\n};\n\nconst getFileSync = (file, cwd) => {\n\tconst filePath = path.join(cwd, file);\n\tconst content = fs.readFileSync(filePath, 'utf8');\n\n\treturn {\n\t\tcwd,\n\t\tfilePath,\n\t\tcontent\n\t};\n};\n\nconst normalizeOptions = ({\n\tignore = [],\n\tcwd = slash(process.cwd())\n} = {}) => {\n\treturn {ignore, cwd};\n};\n\nmodule.exports = async options => {\n\toptions = normalizeOptions(options);\n\n\tconst paths = await fastGlob('**/.gitignore', {\n\t\tignore: DEFAULT_IGNORE.concat(options.ignore),\n\t\tcwd: options.cwd\n\t});\n\n\tconst files = await Promise.all(paths.map(file => getFile(file, options.cwd)));\n\tconst ignores = reduceIgnore(files);\n\n\treturn getIsIgnoredPredecate(ignores, options.cwd);\n};\n\nmodule.exports.sync = options => {\n\toptions = normalizeOptions(options);\n\n\tconst paths = fastGlob.sync('**/.gitignore', {\n\t\tignore: DEFAULT_IGNORE.concat(options.ignore),\n\t\tcwd: options.cwd\n\t});\n\n\tconst files = paths.map(file => getFileSync(file, options.cwd));\n\tconst ignores = reduceIgnore(files);\n\n\treturn getIsIgnoredPredecate(ignores, options.cwd);\n};\n", "'use strict';\nconst {Transform} = require('stream');\n\nclass ObjectTransform extends Transform {\n\tconstructor() {\n\t\tsuper({\n\t\t\tobjectMode: true\n\t\t});\n\t}\n}\n\nclass FilterStream extends ObjectTransform {\n\tconstructor(filter) {\n\t\tsuper();\n\t\tthis._filter = filter;\n\t}\n\n\t_transform(data, encoding, callback) {\n\t\tif (this._filter(data)) {\n\t\t\tthis.push(data);\n\t\t}\n\n\t\tcallback();\n\t}\n}\n\nclass UniqueStream extends ObjectTransform {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._pushed = new Set();\n\t}\n\n\t_transform(data, encoding, callback) {\n\t\tif (!this._pushed.has(data)) {\n\t\t\tthis.push(data);\n\t\t\tthis._pushed.add(data);\n\t\t}\n\n\t\tcallback();\n\t}\n}\n\nmodule.exports = {\n\tFilterStream,\n\tUniqueStream\n};\n", "'use strict';\nconst fs = require('fs');\nconst arrayUnion = require('array-union');\nconst merge2 = require('merge2');\nconst fastGlob = require('fast-glob');\nconst dirGlob = require('dir-glob');\nconst gitignore = require('./gitignore');\nconst {FilterStream, UniqueStream} = require('./stream-utils');\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n\tif (!patterns.every(pattern => typeof pattern === 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst checkCwdOption = (options = {}) => {\n\tif (!options.cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = fs.statSync(options.cwd);\n\t} catch {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nconst generateGlobTasks = (patterns, taskOptions) => {\n\tpatterns = arrayUnion([].concat(patterns));\n\tassertPatternsInput(patterns);\n\tcheckCwdOption(taskOptions);\n\n\tconst globTasks = [];\n\n\ttaskOptions = {\n\t\tignore: [],\n\t\texpandDirectories: true,\n\t\t...taskOptions\n\t};\n\n\tfor (const [index, pattern] of patterns.entries()) {\n\t\tif (isNegative(pattern)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ignore = patterns\n\t\t\t.slice(index)\n\t\t\t.filter(pattern => isNegative(pattern))\n\t\t\t.map(pattern => pattern.slice(1));\n\n\t\tconst options = {\n\t\t\t...taskOptions,\n\t\t\tignore: taskOptions.ignore.concat(ignore)\n\t\t};\n\n\t\tglobTasks.push({pattern, options});\n\t}\n\n\treturn globTasks;\n};\n\nconst globDirs = (task, fn) => {\n\tlet options = {};\n\tif (task.options.cwd) {\n\t\toptions.cwd = task.options.cwd;\n\t}\n\n\tif (Array.isArray(task.options.expandDirectories)) {\n\t\toptions = {\n\t\t\t...options,\n\t\t\tfiles: task.options.expandDirectories\n\t\t};\n\t} else if (typeof task.options.expandDirectories === 'object') {\n\t\toptions = {\n\t\t\t...options,\n\t\t\t...task.options.expandDirectories\n\t\t};\n\t}\n\n\treturn fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nconst getFilterSync = options => {\n\treturn options && options.gitignore ?\n\t\tgitignore.sync({cwd: options.cwd, ignore: options.ignore}) :\n\t\tDEFAULT_FILTER;\n};\n\nconst globToTask = task => glob => {\n\tconst {options} = task;\n\tif (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n\t\toptions.ignore = dirGlob.sync(options.ignore);\n\t}\n\n\treturn {\n\t\tpattern: glob,\n\t\toptions\n\t};\n};\n\nmodule.exports = async (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst getFilter = async () => {\n\t\treturn options && options.gitignore ?\n\t\t\tgitignore({cwd: options.cwd, ignore: options.ignore}) :\n\t\t\tDEFAULT_FILTER;\n\t};\n\n\tconst getTasks = async () => {\n\t\tconst tasks = await Promise.all(globTasks.map(async task => {\n\t\t\tconst globs = await getPattern(task, dirGlob);\n\t\t\treturn Promise.all(globs.map(globToTask(task)));\n\t\t}));\n\n\t\treturn arrayUnion(...tasks);\n\t};\n\n\tconst [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n\tconst paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n\n\treturn arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nmodule.exports.sync = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\n\tlet matches = [];\n\tfor (const task of tasks) {\n\t\tmatches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));\n\t}\n\n\treturn matches.filter(path_ => !filter(path_));\n};\n\nmodule.exports.stream = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\tconst filterStream = new FilterStream(p => !filter(p));\n\tconst uniqueStream = new UniqueStream();\n\n\treturn merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))\n\t\t.pipe(filterStream)\n\t\t.pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, options) => []\n\t.concat(patterns)\n\t.some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nmodule.exports.gitignore = gitignore;\n", "'use strict';\n\nmodule.exports = (string, count = 1, options) => {\n\toptions = {\n\t\tindent: ' ',\n\t\tincludeEmptyLines: false,\n\t\t...options\n\t};\n\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n\t\t);\n\t}\n\n\tif (typeof count !== 'number') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n\t\t);\n\t}\n\n\tif (typeof options.indent !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``\n\t\t);\n\t}\n\n\tif (count === 0) {\n\t\treturn string;\n\t}\n\n\tconst regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n\n\treturn string.replace(regex, options.indent.repeat(count));\n};\n"],
  "mappings": "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",
  "names": ["pattern", "tasks"]
}
