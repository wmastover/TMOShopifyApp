{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/isexe@3.1.1/node_modules/isexe/src/posix.ts", "../../../node_modules/.pnpm/isexe@3.1.1/node_modules/isexe/src/win32.ts", "../../../node_modules/.pnpm/isexe@3.1.1/node_modules/isexe/dist/cjs/options.js", "../../../node_modules/.pnpm/isexe@3.1.1/node_modules/isexe/src/index.ts", "../../../node_modules/.pnpm/which@4.0.0/node_modules/which/lib/index.js"],
  "sourcesContent": ["/**\n * This is the Posix implementation of isexe, which uses the file\n * mode and uid/gid values.\n *\n * @module\n */\n\nimport { Stats, statSync } from 'fs'\nimport { stat } from 'fs/promises'\nimport { IsexeOptions } from './options'\n\n/**\n * Determine whether a path is executable according to the mode and\n * current (or specified) user and group IDs.\n */\nexport const isexe = async (\n  path: string,\n  options: IsexeOptions = {}\n): Promise<boolean> => {\n  const { ignoreErrors = false } = options\n  try {\n    return checkStat(await stat(path), options)\n  } catch (e) {\n    const er = e as NodeJS.ErrnoException\n    if (ignoreErrors || er.code === 'EACCES') return false\n    throw er\n  }\n}\n\n/**\n * Synchronously determine whether a path is executable according to\n * the mode and current (or specified) user and group IDs.\n */\nexport const sync = (\n  path: string,\n  options: IsexeOptions = {}\n): boolean => {\n  const { ignoreErrors = false } = options\n  try {\n    return checkStat(statSync(path), options)\n  } catch (e) {\n    const er = e as NodeJS.ErrnoException\n    if (ignoreErrors || er.code === 'EACCES') return false\n    throw er\n  }\n}\n\nconst checkStat = (stat: Stats, options: IsexeOptions) =>\n  stat.isFile() && checkMode(stat, options)\n\nconst checkMode = (stat: Stats, options: IsexeOptions) => {\n  const myUid = options.uid ?? process.getuid?.()\n  const myGroups = options.groups ?? process.getgroups?.() ?? []\n  const myGid = options.gid ?? process.getgid?.() ?? myGroups[0]\n  if (myUid === undefined || myGid === undefined) {\n    throw new Error('cannot get uid or gid')\n  }\n\n  const groups = new Set([myGid, ...myGroups])\n\n  const mod = stat.mode\n  const uid = stat.uid\n  const gid = stat.gid\n\n  const u = parseInt('100', 8)\n  const g = parseInt('010', 8)\n  const o = parseInt('001', 8)\n  const ug = u | g\n\n  return !!(\n    mod & o ||\n    (mod & g && groups.has(gid)) ||\n    (mod & u && uid === myUid) ||\n    (mod & ug && myUid === 0)\n  )\n}\n", "/**\n * This is the Windows implementation of isexe, which uses the file\n * extension and PATHEXT setting.\n *\n * @module\n */\n\nimport { Stats, statSync } from 'fs'\nimport { stat } from 'fs/promises'\nimport { IsexeOptions } from './options'\n\n/**\n * Determine whether a path is executable based on the file extension\n * and PATHEXT environment variable (or specified pathExt option)\n */\nexport const isexe = async (\n  path: string,\n  options: IsexeOptions = {}\n): Promise<boolean> => {\n  const { ignoreErrors = false } = options\n  try {\n    return checkStat(await stat(path), path, options)\n  } catch (e) {\n    const er = e as NodeJS.ErrnoException\n    if (ignoreErrors || er.code === 'EACCES') return false\n    throw er\n  }\n}\n\n/**\n * Synchronously determine whether a path is executable based on the file\n * extension and PATHEXT environment variable (or specified pathExt option)\n */\nexport const sync = (\n  path: string,\n  options: IsexeOptions = {}\n): boolean => {\n  const { ignoreErrors = false } = options\n  try {\n    return checkStat(statSync(path), path, options)\n  } catch (e) {\n    const er = e as NodeJS.ErrnoException\n    if (ignoreErrors || er.code === 'EACCES') return false\n    throw er\n  }\n}\n\nconst checkPathExt = (path: string, options: IsexeOptions) => {\n  const { pathExt = process.env.PATHEXT || '' } = options\n  const peSplit = pathExt.split(';')\n  if (peSplit.indexOf('') !== -1) {\n    return true\n  }\n\n  for (let i = 0; i < peSplit.length; i++) {\n    const p = peSplit[i].toLowerCase()\n    const ext = path.substring(path.length - p.length).toLowerCase()\n\n    if (p && ext === p) {\n      return true\n    }\n  }\n  return false\n}\n\nconst checkStat = (stat: Stats, path: string, options: IsexeOptions) =>\n  stat.isFile() && checkPathExt(path, options)\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=options.js.map", "import * as posix from './posix.js'\nimport * as win32 from './win32.js'\nexport * from './options.js'\nexport { win32, posix }\n\nconst platform = process.env._ISEXE_TEST_PLATFORM_ || process.platform\nconst impl = platform === 'win32' ? win32 : posix\n\n/**\n * Determine whether a path is executable on the current platform.\n */\nexport const isexe = impl.isexe\n/**\n * Synchronously determine whether a path is executable on the\n * current platform.\n */\nexport const sync = impl.sync\n", "const { isexe, sync: isexeSync } = require('isexe')\nconst { join, delimiter, sep, posix } = require('path')\n\nconst isWindows = process.platform === 'win32'\n\n// used to check for slashed in commands passed in. always checks for the posix\n// seperator on all platforms, and checks for the current separator when not on\n// a posix platform. don't use the isWindows check for this since that is mocked\n// in tests but we still need the code to actually work when called. that is also\n// why it is ignored from coverage.\n/* istanbul ignore next */\nconst rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? '' : sep}]`.replace(/(\\\\)/g, '\\\\$1'))\nconst rRel = new RegExp(`^\\\\.${rSlash.source}`)\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, {\n  path: optPath = process.env.PATH,\n  pathExt: optPathExt = process.env.PATHEXT,\n  delimiter: optDelimiter = delimiter,\n}) => {\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(rSlash) ? [''] : [\n    // windows always checks the cwd first\n    ...(isWindows ? [process.cwd()] : []),\n    ...(optPath || /* istanbul ignore next: very unusual */ '').split(optDelimiter),\n  ]\n\n  if (isWindows) {\n    const pathExtExe = optPathExt ||\n      ['.EXE', '.CMD', '.BAT', '.COM'].join(optDelimiter)\n    const pathExt = pathExtExe.split(optDelimiter).flatMap((item) => [item, item.toLowerCase()])\n    if (cmd.includes('.') && pathExt[0] !== '') {\n      pathExt.unshift('')\n    }\n    return { pathEnv, pathExt, pathExtExe }\n  }\n\n  return { pathEnv, pathExt: [''] }\n}\n\nconst getPathPart = (raw, cmd) => {\n  const pathPart = /^\".*\"$/.test(raw) ? raw.slice(1, -1) : raw\n  const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : ''\n  return prefix + join(pathPart, cmd)\n}\n\nconst which = async (cmd, opt = {}) => {\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (const envPart of pathEnv) {\n    const p = getPathPart(envPart, cmd)\n\n    for (const ext of pathExt) {\n      const withExt = p + ext\n      const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true })\n      if (is) {\n        if (!opt.all) {\n          return withExt\n        }\n        found.push(withExt)\n      }\n    }\n  }\n\n  if (opt.all && found.length) {\n    return found\n  }\n\n  if (opt.nothrow) {\n    return null\n  }\n\n  throw getNotFoundError(cmd)\n}\n\nconst whichSync = (cmd, opt = {}) => {\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (const pathEnvPart of pathEnv) {\n    const p = getPathPart(pathEnvPart, cmd)\n\n    for (const ext of pathExt) {\n      const withExt = p + ext\n      const is = isexeSync(withExt, { pathExt: pathExtExe, ignoreErrors: true })\n      if (is) {\n        if (!opt.all) {\n          return withExt\n        }\n        found.push(withExt)\n      }\n    }\n  }\n\n  if (opt.all && found.length) {\n    return found\n  }\n\n  if (opt.nothrow) {\n    return null\n  }\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n"],
  "mappings": "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",
  "names": []
}
